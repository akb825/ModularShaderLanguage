// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MSLB_MSLB_H_
#define FLATBUFFERS_GENERATED_MSLB_MSLB_H_

#include "flatbuffers/flatbuffers.h"

namespace mslb {

struct RasterizationState;

struct MultisampleState;

struct StencilOpState;

struct DepthStencilState;

struct BlendAttachmentState;

struct BlendState;

struct RenderState;

struct SamplerState;

struct ArrayInfo;

struct StructMember;

struct Struct;

struct Uniform;

struct Attribute;

struct FragmentOutput;

struct Shader;

struct Pipeline;

struct ShaderData;

struct Module;

enum class Stage : uint8_t {
  Vertex = 0,
  TessellationControl = 1,
  TessellationEvaluation = 2,
  Geometry = 3,
  Fragment = 4,
  Compute = 5,
  MIN = Vertex,
  MAX = Compute
};

inline Stage (&EnumValuesStage())[6] {
  static Stage values[] = {
    Stage::Vertex,
    Stage::TessellationControl,
    Stage::TessellationEvaluation,
    Stage::Geometry,
    Stage::Fragment,
    Stage::Compute
  };
  return values;
}

inline const char **EnumNamesStage() {
  static const char *names[] = {
    "Vertex",
    "TessellationControl",
    "TessellationEvaluation",
    "Geometry",
    "Fragment",
    "Compute",
    nullptr
  };
  return names;
}

inline const char *EnumNameStage(Stage e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStage()[index];
}

enum class Type : uint8_t {
  Float = 0,
  Vec2 = 1,
  Vec3 = 2,
  Vec4 = 3,
  Double = 4,
  DVec2 = 5,
  DVec3 = 6,
  DVec4 = 7,
  Int = 8,
  IVec2 = 9,
  IVec3 = 10,
  IVec4 = 11,
  UInt = 12,
  UVec2 = 13,
  UVec3 = 14,
  UVec4 = 15,
  Bool = 16,
  BVec2 = 17,
  BVec3 = 18,
  BVec4 = 19,
  Mat2 = 20,
  Mat3 = 21,
  Mat4 = 22,
  Mat2x3 = 23,
  Mat2x4 = 24,
  Mat3x2 = 25,
  Mat3x4 = 26,
  Mat4x2 = 27,
  Mat4x3 = 28,
  DMat2 = 29,
  DMat3 = 30,
  DMat4 = 31,
  DMat2x3 = 32,
  DMat2x4 = 33,
  DMat3x2 = 34,
  DMat3x4 = 35,
  DMat4x2 = 36,
  DMat4x3 = 37,
  Sampler1D = 38,
  Sampler2D = 39,
  Sampler3D = 40,
  SamplerCube = 41,
  Sampler1DShadow = 42,
  Sampler2DShadow = 43,
  Sampler1DArray = 44,
  Sampler2DArray = 45,
  Sampler1DArrayShadow = 46,
  Sampler2DArrayShadow = 47,
  Sampler2DMS = 48,
  Sampler2DMSArray = 49,
  SamplerCubeShadow = 50,
  SamplerBuffer = 51,
  Sampler2DRect = 52,
  Sampler2DRectShadow = 53,
  ISampler1D = 54,
  ISampler2D = 55,
  ISampler3D = 56,
  ISamplerCube = 57,
  ISampler1DArray = 58,
  ISampler2DArray = 59,
  ISampler2DMS = 60,
  ISampler2DMSArray = 61,
  ISampler2DRect = 62,
  USampler1D = 63,
  USampler2D = 64,
  USampler3D = 65,
  USamplerCube = 66,
  USampler1DArray = 67,
  USampler2DArray = 68,
  USampler2DMS = 69,
  USampler2DMSArray = 70,
  USampler2DRect = 71,
  Image1D = 72,
  Image2D = 73,
  Image3D = 74,
  ImageCube = 75,
  Image1DArray = 76,
  Image2DArray = 77,
  Image2DMS = 78,
  Image2DMSArray = 79,
  ImageBuffer = 80,
  Image2DRect = 81,
  IImage1D = 82,
  IImage2D = 83,
  IImage3D = 84,
  IImageCube = 85,
  IImage1DArray = 86,
  IImage2DArray = 87,
  IImage2DMS = 88,
  IImage2DMSArray = 89,
  IImage2DRect = 90,
  UImage1D = 91,
  UImage2D = 92,
  UImage3D = 93,
  UImageCube = 94,
  UImage1DArray = 95,
  UImage2DArray = 96,
  UImage2DMS = 97,
  UImage2DMSArray = 98,
  UImage2DRect = 99,
  SubpassInput = 100,
  SubpassInputMS = 101,
  ISubpassInput = 102,
  ISubpassInputMS = 103,
  USubpassInput = 104,
  USubpassInputMS = 105,
  Struct = 106,
  MIN = Float,
  MAX = Struct
};

inline Type (&EnumValuesType())[107] {
  static Type values[] = {
    Type::Float,
    Type::Vec2,
    Type::Vec3,
    Type::Vec4,
    Type::Double,
    Type::DVec2,
    Type::DVec3,
    Type::DVec4,
    Type::Int,
    Type::IVec2,
    Type::IVec3,
    Type::IVec4,
    Type::UInt,
    Type::UVec2,
    Type::UVec3,
    Type::UVec4,
    Type::Bool,
    Type::BVec2,
    Type::BVec3,
    Type::BVec4,
    Type::Mat2,
    Type::Mat3,
    Type::Mat4,
    Type::Mat2x3,
    Type::Mat2x4,
    Type::Mat3x2,
    Type::Mat3x4,
    Type::Mat4x2,
    Type::Mat4x3,
    Type::DMat2,
    Type::DMat3,
    Type::DMat4,
    Type::DMat2x3,
    Type::DMat2x4,
    Type::DMat3x2,
    Type::DMat3x4,
    Type::DMat4x2,
    Type::DMat4x3,
    Type::Sampler1D,
    Type::Sampler2D,
    Type::Sampler3D,
    Type::SamplerCube,
    Type::Sampler1DShadow,
    Type::Sampler2DShadow,
    Type::Sampler1DArray,
    Type::Sampler2DArray,
    Type::Sampler1DArrayShadow,
    Type::Sampler2DArrayShadow,
    Type::Sampler2DMS,
    Type::Sampler2DMSArray,
    Type::SamplerCubeShadow,
    Type::SamplerBuffer,
    Type::Sampler2DRect,
    Type::Sampler2DRectShadow,
    Type::ISampler1D,
    Type::ISampler2D,
    Type::ISampler3D,
    Type::ISamplerCube,
    Type::ISampler1DArray,
    Type::ISampler2DArray,
    Type::ISampler2DMS,
    Type::ISampler2DMSArray,
    Type::ISampler2DRect,
    Type::USampler1D,
    Type::USampler2D,
    Type::USampler3D,
    Type::USamplerCube,
    Type::USampler1DArray,
    Type::USampler2DArray,
    Type::USampler2DMS,
    Type::USampler2DMSArray,
    Type::USampler2DRect,
    Type::Image1D,
    Type::Image2D,
    Type::Image3D,
    Type::ImageCube,
    Type::Image1DArray,
    Type::Image2DArray,
    Type::Image2DMS,
    Type::Image2DMSArray,
    Type::ImageBuffer,
    Type::Image2DRect,
    Type::IImage1D,
    Type::IImage2D,
    Type::IImage3D,
    Type::IImageCube,
    Type::IImage1DArray,
    Type::IImage2DArray,
    Type::IImage2DMS,
    Type::IImage2DMSArray,
    Type::IImage2DRect,
    Type::UImage1D,
    Type::UImage2D,
    Type::UImage3D,
    Type::UImageCube,
    Type::UImage1DArray,
    Type::UImage2DArray,
    Type::UImage2DMS,
    Type::UImage2DMSArray,
    Type::UImage2DRect,
    Type::SubpassInput,
    Type::SubpassInputMS,
    Type::ISubpassInput,
    Type::ISubpassInputMS,
    Type::USubpassInput,
    Type::USubpassInputMS,
    Type::Struct
  };
  return values;
}

inline const char **EnumNamesType() {
  static const char *names[] = {
    "Float",
    "Vec2",
    "Vec3",
    "Vec4",
    "Double",
    "DVec2",
    "DVec3",
    "DVec4",
    "Int",
    "IVec2",
    "IVec3",
    "IVec4",
    "UInt",
    "UVec2",
    "UVec3",
    "UVec4",
    "Bool",
    "BVec2",
    "BVec3",
    "BVec4",
    "Mat2",
    "Mat3",
    "Mat4",
    "Mat2x3",
    "Mat2x4",
    "Mat3x2",
    "Mat3x4",
    "Mat4x2",
    "Mat4x3",
    "DMat2",
    "DMat3",
    "DMat4",
    "DMat2x3",
    "DMat2x4",
    "DMat3x2",
    "DMat3x4",
    "DMat4x2",
    "DMat4x3",
    "Sampler1D",
    "Sampler2D",
    "Sampler3D",
    "SamplerCube",
    "Sampler1DShadow",
    "Sampler2DShadow",
    "Sampler1DArray",
    "Sampler2DArray",
    "Sampler1DArrayShadow",
    "Sampler2DArrayShadow",
    "Sampler2DMS",
    "Sampler2DMSArray",
    "SamplerCubeShadow",
    "SamplerBuffer",
    "Sampler2DRect",
    "Sampler2DRectShadow",
    "ISampler1D",
    "ISampler2D",
    "ISampler3D",
    "ISamplerCube",
    "ISampler1DArray",
    "ISampler2DArray",
    "ISampler2DMS",
    "ISampler2DMSArray",
    "ISampler2DRect",
    "USampler1D",
    "USampler2D",
    "USampler3D",
    "USamplerCube",
    "USampler1DArray",
    "USampler2DArray",
    "USampler2DMS",
    "USampler2DMSArray",
    "USampler2DRect",
    "Image1D",
    "Image2D",
    "Image3D",
    "ImageCube",
    "Image1DArray",
    "Image2DArray",
    "Image2DMS",
    "Image2DMSArray",
    "ImageBuffer",
    "Image2DRect",
    "IImage1D",
    "IImage2D",
    "IImage3D",
    "IImageCube",
    "IImage1DArray",
    "IImage2DArray",
    "IImage2DMS",
    "IImage2DMSArray",
    "IImage2DRect",
    "UImage1D",
    "UImage2D",
    "UImage3D",
    "UImageCube",
    "UImage1DArray",
    "UImage2DArray",
    "UImage2DMS",
    "UImage2DMSArray",
    "UImage2DRect",
    "SubpassInput",
    "SubpassInputMS",
    "ISubpassInput",
    "ISubpassInputMS",
    "USubpassInput",
    "USubpassInputMS",
    "Struct",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesType()[index];
}

enum class UniformType : uint8_t {
  PushConstant = 0,
  Block = 1,
  BlockBuffer = 2,
  Image = 3,
  SampledImage = 4,
  SubpassInput = 5,
  MIN = PushConstant,
  MAX = SubpassInput
};

inline UniformType (&EnumValuesUniformType())[6] {
  static UniformType values[] = {
    UniformType::PushConstant,
    UniformType::Block,
    UniformType::BlockBuffer,
    UniformType::Image,
    UniformType::SampledImage,
    UniformType::SubpassInput
  };
  return values;
}

inline const char **EnumNamesUniformType() {
  static const char *names[] = {
    "PushConstant",
    "Block",
    "BlockBuffer",
    "Image",
    "SampledImage",
    "SubpassInput",
    nullptr
  };
  return names;
}

inline const char *EnumNameUniformType(UniformType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesUniformType()[index];
}

enum class Bool : int8_t {
  Unset = -1,
  False = 0,
  True = 1,
  MIN = Unset,
  MAX = True
};

inline Bool (&EnumValuesBool())[3] {
  static Bool values[] = {
    Bool::Unset,
    Bool::False,
    Bool::True
  };
  return values;
}

inline const char **EnumNamesBool() {
  static const char *names[] = {
    "Unset",
    "False",
    "True",
    nullptr
  };
  return names;
}

inline const char *EnumNameBool(Bool e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(Bool::Unset);
  return EnumNamesBool()[index];
}

enum class PolygonMode : int8_t {
  Unset = -1,
  Fill = 0,
  Line = 1,
  Point = 2,
  MIN = Unset,
  MAX = Point
};

inline PolygonMode (&EnumValuesPolygonMode())[4] {
  static PolygonMode values[] = {
    PolygonMode::Unset,
    PolygonMode::Fill,
    PolygonMode::Line,
    PolygonMode::Point
  };
  return values;
}

inline const char **EnumNamesPolygonMode() {
  static const char *names[] = {
    "Unset",
    "Fill",
    "Line",
    "Point",
    nullptr
  };
  return names;
}

inline const char *EnumNamePolygonMode(PolygonMode e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(PolygonMode::Unset);
  return EnumNamesPolygonMode()[index];
}

enum class CullMode : int8_t {
  Unset = -1,
  None = 0,
  Front = 1,
  Back = 2,
  FrontAndBack = 3,
  MIN = Unset,
  MAX = FrontAndBack
};

inline CullMode (&EnumValuesCullMode())[5] {
  static CullMode values[] = {
    CullMode::Unset,
    CullMode::None,
    CullMode::Front,
    CullMode::Back,
    CullMode::FrontAndBack
  };
  return values;
}

inline const char **EnumNamesCullMode() {
  static const char *names[] = {
    "Unset",
    "None",
    "Front",
    "Back",
    "FrontAndBack",
    nullptr
  };
  return names;
}

inline const char *EnumNameCullMode(CullMode e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(CullMode::Unset);
  return EnumNamesCullMode()[index];
}

enum class FrontFace : int8_t {
  Unset = -1,
  CounterClockwise = 0,
  Clockwise = 1,
  MIN = Unset,
  MAX = Clockwise
};

inline FrontFace (&EnumValuesFrontFace())[3] {
  static FrontFace values[] = {
    FrontFace::Unset,
    FrontFace::CounterClockwise,
    FrontFace::Clockwise
  };
  return values;
}

inline const char **EnumNamesFrontFace() {
  static const char *names[] = {
    "Unset",
    "CounterClockwise",
    "Clockwise",
    nullptr
  };
  return names;
}

inline const char *EnumNameFrontFace(FrontFace e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(FrontFace::Unset);
  return EnumNamesFrontFace()[index];
}

enum class StencilOp : int8_t {
  Unset = -1,
  Keep = 0,
  Zero = 1,
  Replace = 2,
  IncrementAndClamp = 3,
  DecrementAndClamp = 4,
  Invert = 5,
  IncrementAndWrap = 6,
  DecrementAndWrap = 7,
  MIN = Unset,
  MAX = DecrementAndWrap
};

inline StencilOp (&EnumValuesStencilOp())[9] {
  static StencilOp values[] = {
    StencilOp::Unset,
    StencilOp::Keep,
    StencilOp::Zero,
    StencilOp::Replace,
    StencilOp::IncrementAndClamp,
    StencilOp::DecrementAndClamp,
    StencilOp::Invert,
    StencilOp::IncrementAndWrap,
    StencilOp::DecrementAndWrap
  };
  return values;
}

inline const char **EnumNamesStencilOp() {
  static const char *names[] = {
    "Unset",
    "Keep",
    "Zero",
    "Replace",
    "IncrementAndClamp",
    "DecrementAndClamp",
    "Invert",
    "IncrementAndWrap",
    "DecrementAndWrap",
    nullptr
  };
  return names;
}

inline const char *EnumNameStencilOp(StencilOp e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(StencilOp::Unset);
  return EnumNamesStencilOp()[index];
}

enum class CompareOp : int8_t {
  Unset = -1,
  Never = 0,
  Less = 1,
  Equal = 2,
  LessOrEqual = 3,
  Greater = 4,
  NotEqual = 5,
  GreaterOrEqual = 6,
  Always = 7,
  MIN = Unset,
  MAX = Always
};

inline CompareOp (&EnumValuesCompareOp())[9] {
  static CompareOp values[] = {
    CompareOp::Unset,
    CompareOp::Never,
    CompareOp::Less,
    CompareOp::Equal,
    CompareOp::LessOrEqual,
    CompareOp::Greater,
    CompareOp::NotEqual,
    CompareOp::GreaterOrEqual,
    CompareOp::Always
  };
  return values;
}

inline const char **EnumNamesCompareOp() {
  static const char *names[] = {
    "Unset",
    "Never",
    "Less",
    "Equal",
    "LessOrEqual",
    "Greater",
    "NotEqual",
    "GreaterOrEqual",
    "Always",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompareOp(CompareOp e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(CompareOp::Unset);
  return EnumNamesCompareOp()[index];
}

enum class BlendFactor : int8_t {
  Unset = -1,
  Zero = 0,
  One = 1,
  SrcColor = 2,
  OneMinusSrcColor = 3,
  DstColor = 4,
  OneMinusDstColor = 5,
  SrcAlpha = 6,
  OneMinusSrcAlpha = 7,
  DstAlpha = 8,
  OneMinusDstAlpha = 9,
  ConstColor = 10,
  OneMinusConstColor = 11,
  ConstAlpha = 12,
  OneMinusConstAlpha = 13,
  SrcAlphaSaturate = 14,
  Src1Color = 15,
  OneMinusSrc1Color = 16,
  Src1Alpha = 17,
  OneMinusSrc1Alpha = 18,
  MIN = Unset,
  MAX = OneMinusSrc1Alpha
};

inline BlendFactor (&EnumValuesBlendFactor())[20] {
  static BlendFactor values[] = {
    BlendFactor::Unset,
    BlendFactor::Zero,
    BlendFactor::One,
    BlendFactor::SrcColor,
    BlendFactor::OneMinusSrcColor,
    BlendFactor::DstColor,
    BlendFactor::OneMinusDstColor,
    BlendFactor::SrcAlpha,
    BlendFactor::OneMinusSrcAlpha,
    BlendFactor::DstAlpha,
    BlendFactor::OneMinusDstAlpha,
    BlendFactor::ConstColor,
    BlendFactor::OneMinusConstColor,
    BlendFactor::ConstAlpha,
    BlendFactor::OneMinusConstAlpha,
    BlendFactor::SrcAlphaSaturate,
    BlendFactor::Src1Color,
    BlendFactor::OneMinusSrc1Color,
    BlendFactor::Src1Alpha,
    BlendFactor::OneMinusSrc1Alpha
  };
  return values;
}

inline const char **EnumNamesBlendFactor() {
  static const char *names[] = {
    "Unset",
    "Zero",
    "One",
    "SrcColor",
    "OneMinusSrcColor",
    "DstColor",
    "OneMinusDstColor",
    "SrcAlpha",
    "OneMinusSrcAlpha",
    "DstAlpha",
    "OneMinusDstAlpha",
    "ConstColor",
    "OneMinusConstColor",
    "ConstAlpha",
    "OneMinusConstAlpha",
    "SrcAlphaSaturate",
    "Src1Color",
    "OneMinusSrc1Color",
    "Src1Alpha",
    "OneMinusSrc1Alpha",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlendFactor(BlendFactor e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(BlendFactor::Unset);
  return EnumNamesBlendFactor()[index];
}

enum class BlendOp : int8_t {
  Unset = -1,
  Add = 0,
  Subtract = 1,
  ReverseSubtract = 2,
  Min = 3,
  Max = 4,
  MIN = Unset,
  MAX = Max
};

inline BlendOp (&EnumValuesBlendOp())[6] {
  static BlendOp values[] = {
    BlendOp::Unset,
    BlendOp::Add,
    BlendOp::Subtract,
    BlendOp::ReverseSubtract,
    BlendOp::Min,
    BlendOp::Max
  };
  return values;
}

inline const char **EnumNamesBlendOp() {
  static const char *names[] = {
    "Unset",
    "Add",
    "Subtract",
    "ReverseSubtract",
    "Min",
    "Max",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlendOp(BlendOp e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(BlendOp::Unset);
  return EnumNamesBlendOp()[index];
}

enum class ColorMask : int8_t {
  Unset = -1,
  None = 0,
  Red = 1,
  Green = 2,
  Blue = 4,
  Alpha = 8,
  MIN = Unset,
  MAX = Alpha
};

inline ColorMask (&EnumValuesColorMask())[6] {
  static ColorMask values[] = {
    ColorMask::Unset,
    ColorMask::None,
    ColorMask::Red,
    ColorMask::Green,
    ColorMask::Blue,
    ColorMask::Alpha
  };
  return values;
}

inline const char **EnumNamesColorMask() {
  static const char *names[] = {
    "Unset",
    "None",
    "Red",
    "Green",
    "",
    "Blue",
    "",
    "",
    "",
    "Alpha",
    nullptr
  };
  return names;
}

inline const char *EnumNameColorMask(ColorMask e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(ColorMask::Unset);
  return EnumNamesColorMask()[index];
}

enum class LogicOp : int8_t {
  Unset = -1,
  Clear = 0,
  And = 1,
  AndReverse = 2,
  Copy = 3,
  AndInverted = 4,
  NoOp = 5,
  Xor = 6,
  Or = 7,
  Nor = 8,
  Equivalent = 9,
  Invert = 10,
  OrReverse = 11,
  CopyInverted = 12,
  OrInverted = 13,
  Nand = 14,
  Set = 15,
  MIN = Unset,
  MAX = Set
};

inline LogicOp (&EnumValuesLogicOp())[17] {
  static LogicOp values[] = {
    LogicOp::Unset,
    LogicOp::Clear,
    LogicOp::And,
    LogicOp::AndReverse,
    LogicOp::Copy,
    LogicOp::AndInverted,
    LogicOp::NoOp,
    LogicOp::Xor,
    LogicOp::Or,
    LogicOp::Nor,
    LogicOp::Equivalent,
    LogicOp::Invert,
    LogicOp::OrReverse,
    LogicOp::CopyInverted,
    LogicOp::OrInverted,
    LogicOp::Nand,
    LogicOp::Set
  };
  return values;
}

inline const char **EnumNamesLogicOp() {
  static const char *names[] = {
    "Unset",
    "Clear",
    "And",
    "AndReverse",
    "Copy",
    "AndInverted",
    "NoOp",
    "Xor",
    "Or",
    "Nor",
    "Equivalent",
    "Invert",
    "OrReverse",
    "CopyInverted",
    "OrInverted",
    "Nand",
    "Set",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogicOp(LogicOp e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(LogicOp::Unset);
  return EnumNamesLogicOp()[index];
}

enum class Filter : int8_t {
  Unset = -1,
  Nearest = 0,
  Linear = 1,
  MIN = Unset,
  MAX = Linear
};

inline Filter (&EnumValuesFilter())[3] {
  static Filter values[] = {
    Filter::Unset,
    Filter::Nearest,
    Filter::Linear
  };
  return values;
}

inline const char **EnumNamesFilter() {
  static const char *names[] = {
    "Unset",
    "Nearest",
    "Linear",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilter(Filter e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(Filter::Unset);
  return EnumNamesFilter()[index];
}

enum class MipFilter : int8_t {
  Unset = -1,
  None = 0,
  Nearest = 1,
  Linear = 2,
  Anisotropic = 3,
  MIN = Unset,
  MAX = Anisotropic
};

inline MipFilter (&EnumValuesMipFilter())[5] {
  static MipFilter values[] = {
    MipFilter::Unset,
    MipFilter::None,
    MipFilter::Nearest,
    MipFilter::Linear,
    MipFilter::Anisotropic
  };
  return values;
}

inline const char **EnumNamesMipFilter() {
  static const char *names[] = {
    "Unset",
    "None",
    "Nearest",
    "Linear",
    "Anisotropic",
    nullptr
  };
  return names;
}

inline const char *EnumNameMipFilter(MipFilter e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(MipFilter::Unset);
  return EnumNamesMipFilter()[index];
}

enum class AddressMode : int8_t {
  Unset = -1,
  Repeat = 0,
  MirroredRepeat = 1,
  ClampToEdge = 2,
  ClampToBorder = 3,
  MirrorOnce = 4,
  MIN = Unset,
  MAX = MirrorOnce
};

inline AddressMode (&EnumValuesAddressMode())[6] {
  static AddressMode values[] = {
    AddressMode::Unset,
    AddressMode::Repeat,
    AddressMode::MirroredRepeat,
    AddressMode::ClampToEdge,
    AddressMode::ClampToBorder,
    AddressMode::MirrorOnce
  };
  return values;
}

inline const char **EnumNamesAddressMode() {
  static const char *names[] = {
    "Unset",
    "Repeat",
    "MirroredRepeat",
    "ClampToEdge",
    "ClampToBorder",
    "MirrorOnce",
    nullptr
  };
  return names;
}

inline const char *EnumNameAddressMode(AddressMode e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(AddressMode::Unset);
  return EnumNamesAddressMode()[index];
}

enum class BorderColor : int8_t {
  Unset = -1,
  TransparentBlack = 0,
  TransparentIntZero = 1,
  OpaqueBlack = 2,
  OpaqueIntZero = 3,
  OpaqueWhite = 4,
  OpaqueIntOne = 5,
  MIN = Unset,
  MAX = OpaqueIntOne
};

inline BorderColor (&EnumValuesBorderColor())[7] {
  static BorderColor values[] = {
    BorderColor::Unset,
    BorderColor::TransparentBlack,
    BorderColor::TransparentIntZero,
    BorderColor::OpaqueBlack,
    BorderColor::OpaqueIntZero,
    BorderColor::OpaqueWhite,
    BorderColor::OpaqueIntOne
  };
  return values;
}

inline const char **EnumNamesBorderColor() {
  static const char *names[] = {
    "Unset",
    "TransparentBlack",
    "TransparentIntZero",
    "OpaqueBlack",
    "OpaqueIntZero",
    "OpaqueWhite",
    "OpaqueIntOne",
    nullptr
  };
  return names;
}

inline const char *EnumNameBorderColor(BorderColor e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(BorderColor::Unset);
  return EnumNamesBorderColor()[index];
}

MANUALLY_ALIGNED_STRUCT(4) RasterizationState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t depthClampEnable_;
  int8_t rasterizerDiscardEnable_;
  int8_t polygonMode_;
  int8_t cullMode_;
  int8_t frontFace_;
  int8_t depthBiasEnable_;
  int16_t padding0__;
  float depthBiasConstantFactor_;
  float depthBiasClamp_;
  float depthBiasSlopeFactor_;
  float lineWidth_;

 public:
  RasterizationState() {
    memset(this, 0, sizeof(RasterizationState));
  }
  RasterizationState(Bool _depthClampEnable, Bool _rasterizerDiscardEnable, PolygonMode _polygonMode, CullMode _cullMode, FrontFace _frontFace, Bool _depthBiasEnable, float _depthBiasConstantFactor, float _depthBiasClamp, float _depthBiasSlopeFactor, float _lineWidth)
      : depthClampEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthClampEnable))),
        rasterizerDiscardEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_rasterizerDiscardEnable))),
        polygonMode_(flatbuffers::EndianScalar(static_cast<int8_t>(_polygonMode))),
        cullMode_(flatbuffers::EndianScalar(static_cast<int8_t>(_cullMode))),
        frontFace_(flatbuffers::EndianScalar(static_cast<int8_t>(_frontFace))),
        depthBiasEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthBiasEnable))),
        padding0__(0),
        depthBiasConstantFactor_(flatbuffers::EndianScalar(_depthBiasConstantFactor)),
        depthBiasClamp_(flatbuffers::EndianScalar(_depthBiasClamp)),
        depthBiasSlopeFactor_(flatbuffers::EndianScalar(_depthBiasSlopeFactor)),
        lineWidth_(flatbuffers::EndianScalar(_lineWidth)) {
    (void)padding0__;
  }
  Bool depthClampEnable() const {
    return static_cast<Bool>(flatbuffers::EndianScalar(depthClampEnable_));
  }
  void mutate_depthClampEnable(Bool _depthClampEnable) {
    flatbuffers::WriteScalar(&depthClampEnable_, static_cast<int8_t>(_depthClampEnable));
  }
  Bool rasterizerDiscardEnable() const {
    return static_cast<Bool>(flatbuffers::EndianScalar(rasterizerDiscardEnable_));
  }
  void mutate_rasterizerDiscardEnable(Bool _rasterizerDiscardEnable) {
    flatbuffers::WriteScalar(&rasterizerDiscardEnable_, static_cast<int8_t>(_rasterizerDiscardEnable));
  }
  PolygonMode polygonMode() const {
    return static_cast<PolygonMode>(flatbuffers::EndianScalar(polygonMode_));
  }
  void mutate_polygonMode(PolygonMode _polygonMode) {
    flatbuffers::WriteScalar(&polygonMode_, static_cast<int8_t>(_polygonMode));
  }
  CullMode cullMode() const {
    return static_cast<CullMode>(flatbuffers::EndianScalar(cullMode_));
  }
  void mutate_cullMode(CullMode _cullMode) {
    flatbuffers::WriteScalar(&cullMode_, static_cast<int8_t>(_cullMode));
  }
  FrontFace frontFace() const {
    return static_cast<FrontFace>(flatbuffers::EndianScalar(frontFace_));
  }
  void mutate_frontFace(FrontFace _frontFace) {
    flatbuffers::WriteScalar(&frontFace_, static_cast<int8_t>(_frontFace));
  }
  Bool depthBiasEnable() const {
    return static_cast<Bool>(flatbuffers::EndianScalar(depthBiasEnable_));
  }
  void mutate_depthBiasEnable(Bool _depthBiasEnable) {
    flatbuffers::WriteScalar(&depthBiasEnable_, static_cast<int8_t>(_depthBiasEnable));
  }
  float depthBiasConstantFactor() const {
    return flatbuffers::EndianScalar(depthBiasConstantFactor_);
  }
  void mutate_depthBiasConstantFactor(float _depthBiasConstantFactor) {
    flatbuffers::WriteScalar(&depthBiasConstantFactor_, _depthBiasConstantFactor);
  }
  float depthBiasClamp() const {
    return flatbuffers::EndianScalar(depthBiasClamp_);
  }
  void mutate_depthBiasClamp(float _depthBiasClamp) {
    flatbuffers::WriteScalar(&depthBiasClamp_, _depthBiasClamp);
  }
  float depthBiasSlopeFactor() const {
    return flatbuffers::EndianScalar(depthBiasSlopeFactor_);
  }
  void mutate_depthBiasSlopeFactor(float _depthBiasSlopeFactor) {
    flatbuffers::WriteScalar(&depthBiasSlopeFactor_, _depthBiasSlopeFactor);
  }
  float lineWidth() const {
    return flatbuffers::EndianScalar(lineWidth_);
  }
  void mutate_lineWidth(float _lineWidth) {
    flatbuffers::WriteScalar(&lineWidth_, _lineWidth);
  }
};
STRUCT_END(RasterizationState, 24);

MANUALLY_ALIGNED_STRUCT(4) MultisampleState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t sampleShadingEnable_;
  int8_t padding0__;  int16_t padding1__;
  float minSampleShading_;
  uint32_t sampleMask_;
  int8_t alphaToCoverageEnable_;
  int8_t alphaToOneEnable_;
  int16_t padding2__;

 public:
  MultisampleState() {
    memset(this, 0, sizeof(MultisampleState));
  }
  MultisampleState(Bool _sampleShadingEnable, float _minSampleShading, uint32_t _sampleMask, Bool _alphaToCoverageEnable, Bool _alphaToOneEnable)
      : sampleShadingEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_sampleShadingEnable))),
        padding0__(0),
        padding1__(0),
        minSampleShading_(flatbuffers::EndianScalar(_minSampleShading)),
        sampleMask_(flatbuffers::EndianScalar(_sampleMask)),
        alphaToCoverageEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_alphaToCoverageEnable))),
        alphaToOneEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_alphaToOneEnable))),
        padding2__(0) {
    (void)padding0__;    (void)padding1__;
    (void)padding2__;
  }
  Bool sampleShadingEnable() const {
    return static_cast<Bool>(flatbuffers::EndianScalar(sampleShadingEnable_));
  }
  void mutate_sampleShadingEnable(Bool _sampleShadingEnable) {
    flatbuffers::WriteScalar(&sampleShadingEnable_, static_cast<int8_t>(_sampleShadingEnable));
  }
  float minSampleShading() const {
    return flatbuffers::EndianScalar(minSampleShading_);
  }
  void mutate_minSampleShading(float _minSampleShading) {
    flatbuffers::WriteScalar(&minSampleShading_, _minSampleShading);
  }
  uint32_t sampleMask() const {
    return flatbuffers::EndianScalar(sampleMask_);
  }
  void mutate_sampleMask(uint32_t _sampleMask) {
    flatbuffers::WriteScalar(&sampleMask_, _sampleMask);
  }
  Bool alphaToCoverageEnable() const {
    return static_cast<Bool>(flatbuffers::EndianScalar(alphaToCoverageEnable_));
  }
  void mutate_alphaToCoverageEnable(Bool _alphaToCoverageEnable) {
    flatbuffers::WriteScalar(&alphaToCoverageEnable_, static_cast<int8_t>(_alphaToCoverageEnable));
  }
  Bool alphaToOneEnable() const {
    return static_cast<Bool>(flatbuffers::EndianScalar(alphaToOneEnable_));
  }
  void mutate_alphaToOneEnable(Bool _alphaToOneEnable) {
    flatbuffers::WriteScalar(&alphaToOneEnable_, static_cast<int8_t>(_alphaToOneEnable));
  }
};
STRUCT_END(MultisampleState, 16);

MANUALLY_ALIGNED_STRUCT(4) StencilOpState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t failOp_;
  int8_t passOp_;
  int8_t depthFailOp_;
  int8_t compareOp_;
  uint32_t compareMask_;
  uint32_t writeMask_;
  uint32_t reference_;

 public:
  StencilOpState() {
    memset(this, 0, sizeof(StencilOpState));
  }
  StencilOpState(StencilOp _failOp, StencilOp _passOp, StencilOp _depthFailOp, CompareOp _compareOp, uint32_t _compareMask, uint32_t _writeMask, uint32_t _reference)
      : failOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_failOp))),
        passOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_passOp))),
        depthFailOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthFailOp))),
        compareOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_compareOp))),
        compareMask_(flatbuffers::EndianScalar(_compareMask)),
        writeMask_(flatbuffers::EndianScalar(_writeMask)),
        reference_(flatbuffers::EndianScalar(_reference)) {
  }
  StencilOp failOp() const {
    return static_cast<StencilOp>(flatbuffers::EndianScalar(failOp_));
  }
  void mutate_failOp(StencilOp _failOp) {
    flatbuffers::WriteScalar(&failOp_, static_cast<int8_t>(_failOp));
  }
  StencilOp passOp() const {
    return static_cast<StencilOp>(flatbuffers::EndianScalar(passOp_));
  }
  void mutate_passOp(StencilOp _passOp) {
    flatbuffers::WriteScalar(&passOp_, static_cast<int8_t>(_passOp));
  }
  StencilOp depthFailOp() const {
    return static_cast<StencilOp>(flatbuffers::EndianScalar(depthFailOp_));
  }
  void mutate_depthFailOp(StencilOp _depthFailOp) {
    flatbuffers::WriteScalar(&depthFailOp_, static_cast<int8_t>(_depthFailOp));
  }
  CompareOp compareOp() const {
    return static_cast<CompareOp>(flatbuffers::EndianScalar(compareOp_));
  }
  void mutate_compareOp(CompareOp _compareOp) {
    flatbuffers::WriteScalar(&compareOp_, static_cast<int8_t>(_compareOp));
  }
  uint32_t compareMask() const {
    return flatbuffers::EndianScalar(compareMask_);
  }
  void mutate_compareMask(uint32_t _compareMask) {
    flatbuffers::WriteScalar(&compareMask_, _compareMask);
  }
  uint32_t writeMask() const {
    return flatbuffers::EndianScalar(writeMask_);
  }
  void mutate_writeMask(uint32_t _writeMask) {
    flatbuffers::WriteScalar(&writeMask_, _writeMask);
  }
  uint32_t reference() const {
    return flatbuffers::EndianScalar(reference_);
  }
  void mutate_reference(uint32_t _reference) {
    flatbuffers::WriteScalar(&reference_, _reference);
  }
};
STRUCT_END(StencilOpState, 16);

MANUALLY_ALIGNED_STRUCT(4) DepthStencilState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t depthTestEnable_;
  int8_t depthWriteEnable_;
  int8_t depthCompareOp_;
  int8_t depthBoundsTestEnable_;
  int8_t stencilTestEnable_;
  int8_t padding0__;  int16_t padding1__;
  StencilOpState frontStencil_;
  StencilOpState backStencil_;
  float minDepthBounds_;
  float maxDepthBounds_;

 public:
  DepthStencilState() {
    memset(this, 0, sizeof(DepthStencilState));
  }
  DepthStencilState(Bool _depthTestEnable, Bool _depthWriteEnable, CompareOp _depthCompareOp, Bool _depthBoundsTestEnable, Bool _stencilTestEnable, const StencilOpState &_frontStencil, const StencilOpState &_backStencil, float _minDepthBounds, float _maxDepthBounds)
      : depthTestEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthTestEnable))),
        depthWriteEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthWriteEnable))),
        depthCompareOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthCompareOp))),
        depthBoundsTestEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthBoundsTestEnable))),
        stencilTestEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_stencilTestEnable))),
        padding0__(0),
        padding1__(0),
        frontStencil_(_frontStencil),
        backStencil_(_backStencil),
        minDepthBounds_(flatbuffers::EndianScalar(_minDepthBounds)),
        maxDepthBounds_(flatbuffers::EndianScalar(_maxDepthBounds)) {
    (void)padding0__;    (void)padding1__;
  }
  Bool depthTestEnable() const {
    return static_cast<Bool>(flatbuffers::EndianScalar(depthTestEnable_));
  }
  void mutate_depthTestEnable(Bool _depthTestEnable) {
    flatbuffers::WriteScalar(&depthTestEnable_, static_cast<int8_t>(_depthTestEnable));
  }
  Bool depthWriteEnable() const {
    return static_cast<Bool>(flatbuffers::EndianScalar(depthWriteEnable_));
  }
  void mutate_depthWriteEnable(Bool _depthWriteEnable) {
    flatbuffers::WriteScalar(&depthWriteEnable_, static_cast<int8_t>(_depthWriteEnable));
  }
  CompareOp depthCompareOp() const {
    return static_cast<CompareOp>(flatbuffers::EndianScalar(depthCompareOp_));
  }
  void mutate_depthCompareOp(CompareOp _depthCompareOp) {
    flatbuffers::WriteScalar(&depthCompareOp_, static_cast<int8_t>(_depthCompareOp));
  }
  Bool depthBoundsTestEnable() const {
    return static_cast<Bool>(flatbuffers::EndianScalar(depthBoundsTestEnable_));
  }
  void mutate_depthBoundsTestEnable(Bool _depthBoundsTestEnable) {
    flatbuffers::WriteScalar(&depthBoundsTestEnable_, static_cast<int8_t>(_depthBoundsTestEnable));
  }
  Bool stencilTestEnable() const {
    return static_cast<Bool>(flatbuffers::EndianScalar(stencilTestEnable_));
  }
  void mutate_stencilTestEnable(Bool _stencilTestEnable) {
    flatbuffers::WriteScalar(&stencilTestEnable_, static_cast<int8_t>(_stencilTestEnable));
  }
  const StencilOpState &frontStencil() const {
    return frontStencil_;
  }
  StencilOpState &mutable_frontStencil() {
    return frontStencil_;
  }
  const StencilOpState &backStencil() const {
    return backStencil_;
  }
  StencilOpState &mutable_backStencil() {
    return backStencil_;
  }
  float minDepthBounds() const {
    return flatbuffers::EndianScalar(minDepthBounds_);
  }
  void mutate_minDepthBounds(float _minDepthBounds) {
    flatbuffers::WriteScalar(&minDepthBounds_, _minDepthBounds);
  }
  float maxDepthBounds() const {
    return flatbuffers::EndianScalar(maxDepthBounds_);
  }
  void mutate_maxDepthBounds(float _maxDepthBounds) {
    flatbuffers::WriteScalar(&maxDepthBounds_, _maxDepthBounds);
  }
};
STRUCT_END(DepthStencilState, 48);

MANUALLY_ALIGNED_STRUCT(1) BlendAttachmentState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t blendEnable_;
  int8_t srcColorBlendFactor_;
  int8_t dstColorBlendFactor_;
  int8_t colorBlendOp_;
  int8_t srcAlphaBlendFactor_;
  int8_t dstAlphaBlendFactor_;
  int8_t alphaBlendOp_;
  int8_t colorWriteMask_;

 public:
  BlendAttachmentState() {
    memset(this, 0, sizeof(BlendAttachmentState));
  }
  BlendAttachmentState(Bool _blendEnable, BlendFactor _srcColorBlendFactor, BlendFactor _dstColorBlendFactor, BlendOp _colorBlendOp, BlendFactor _srcAlphaBlendFactor, BlendFactor _dstAlphaBlendFactor, BlendOp _alphaBlendOp, ColorMask _colorWriteMask)
      : blendEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_blendEnable))),
        srcColorBlendFactor_(flatbuffers::EndianScalar(static_cast<int8_t>(_srcColorBlendFactor))),
        dstColorBlendFactor_(flatbuffers::EndianScalar(static_cast<int8_t>(_dstColorBlendFactor))),
        colorBlendOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_colorBlendOp))),
        srcAlphaBlendFactor_(flatbuffers::EndianScalar(static_cast<int8_t>(_srcAlphaBlendFactor))),
        dstAlphaBlendFactor_(flatbuffers::EndianScalar(static_cast<int8_t>(_dstAlphaBlendFactor))),
        alphaBlendOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_alphaBlendOp))),
        colorWriteMask_(flatbuffers::EndianScalar(static_cast<int8_t>(_colorWriteMask))) {
  }
  Bool blendEnable() const {
    return static_cast<Bool>(flatbuffers::EndianScalar(blendEnable_));
  }
  void mutate_blendEnable(Bool _blendEnable) {
    flatbuffers::WriteScalar(&blendEnable_, static_cast<int8_t>(_blendEnable));
  }
  BlendFactor srcColorBlendFactor() const {
    return static_cast<BlendFactor>(flatbuffers::EndianScalar(srcColorBlendFactor_));
  }
  void mutate_srcColorBlendFactor(BlendFactor _srcColorBlendFactor) {
    flatbuffers::WriteScalar(&srcColorBlendFactor_, static_cast<int8_t>(_srcColorBlendFactor));
  }
  BlendFactor dstColorBlendFactor() const {
    return static_cast<BlendFactor>(flatbuffers::EndianScalar(dstColorBlendFactor_));
  }
  void mutate_dstColorBlendFactor(BlendFactor _dstColorBlendFactor) {
    flatbuffers::WriteScalar(&dstColorBlendFactor_, static_cast<int8_t>(_dstColorBlendFactor));
  }
  BlendOp colorBlendOp() const {
    return static_cast<BlendOp>(flatbuffers::EndianScalar(colorBlendOp_));
  }
  void mutate_colorBlendOp(BlendOp _colorBlendOp) {
    flatbuffers::WriteScalar(&colorBlendOp_, static_cast<int8_t>(_colorBlendOp));
  }
  BlendFactor srcAlphaBlendFactor() const {
    return static_cast<BlendFactor>(flatbuffers::EndianScalar(srcAlphaBlendFactor_));
  }
  void mutate_srcAlphaBlendFactor(BlendFactor _srcAlphaBlendFactor) {
    flatbuffers::WriteScalar(&srcAlphaBlendFactor_, static_cast<int8_t>(_srcAlphaBlendFactor));
  }
  BlendFactor dstAlphaBlendFactor() const {
    return static_cast<BlendFactor>(flatbuffers::EndianScalar(dstAlphaBlendFactor_));
  }
  void mutate_dstAlphaBlendFactor(BlendFactor _dstAlphaBlendFactor) {
    flatbuffers::WriteScalar(&dstAlphaBlendFactor_, static_cast<int8_t>(_dstAlphaBlendFactor));
  }
  BlendOp alphaBlendOp() const {
    return static_cast<BlendOp>(flatbuffers::EndianScalar(alphaBlendOp_));
  }
  void mutate_alphaBlendOp(BlendOp _alphaBlendOp) {
    flatbuffers::WriteScalar(&alphaBlendOp_, static_cast<int8_t>(_alphaBlendOp));
  }
  ColorMask colorWriteMask() const {
    return static_cast<ColorMask>(flatbuffers::EndianScalar(colorWriteMask_));
  }
  void mutate_colorWriteMask(ColorMask _colorWriteMask) {
    flatbuffers::WriteScalar(&colorWriteMask_, static_cast<int8_t>(_colorWriteMask));
  }
};
STRUCT_END(BlendAttachmentState, 8);

MANUALLY_ALIGNED_STRUCT(4) SamplerState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t minFilter_;
  int8_t magFilter_;
  int8_t mipFilter_;
  int8_t addressModeU_;
  int8_t addressModeV_;
  int8_t addressModeW_;
  int16_t padding0__;
  float mipLodBias_;
  float maxAnisotropy_;
  float minLod_;
  float maxLod_;
  int8_t borderColor_;
  int8_t compareOp_;
  int16_t padding1__;

 public:
  SamplerState() {
    memset(this, 0, sizeof(SamplerState));
  }
  SamplerState(Filter _minFilter, Filter _magFilter, MipFilter _mipFilter, AddressMode _addressModeU, AddressMode _addressModeV, AddressMode _addressModeW, float _mipLodBias, float _maxAnisotropy, float _minLod, float _maxLod, BorderColor _borderColor, CompareOp _compareOp)
      : minFilter_(flatbuffers::EndianScalar(static_cast<int8_t>(_minFilter))),
        magFilter_(flatbuffers::EndianScalar(static_cast<int8_t>(_magFilter))),
        mipFilter_(flatbuffers::EndianScalar(static_cast<int8_t>(_mipFilter))),
        addressModeU_(flatbuffers::EndianScalar(static_cast<int8_t>(_addressModeU))),
        addressModeV_(flatbuffers::EndianScalar(static_cast<int8_t>(_addressModeV))),
        addressModeW_(flatbuffers::EndianScalar(static_cast<int8_t>(_addressModeW))),
        padding0__(0),
        mipLodBias_(flatbuffers::EndianScalar(_mipLodBias)),
        maxAnisotropy_(flatbuffers::EndianScalar(_maxAnisotropy)),
        minLod_(flatbuffers::EndianScalar(_minLod)),
        maxLod_(flatbuffers::EndianScalar(_maxLod)),
        borderColor_(flatbuffers::EndianScalar(static_cast<int8_t>(_borderColor))),
        compareOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_compareOp))),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  Filter minFilter() const {
    return static_cast<Filter>(flatbuffers::EndianScalar(minFilter_));
  }
  void mutate_minFilter(Filter _minFilter) {
    flatbuffers::WriteScalar(&minFilter_, static_cast<int8_t>(_minFilter));
  }
  Filter magFilter() const {
    return static_cast<Filter>(flatbuffers::EndianScalar(magFilter_));
  }
  void mutate_magFilter(Filter _magFilter) {
    flatbuffers::WriteScalar(&magFilter_, static_cast<int8_t>(_magFilter));
  }
  MipFilter mipFilter() const {
    return static_cast<MipFilter>(flatbuffers::EndianScalar(mipFilter_));
  }
  void mutate_mipFilter(MipFilter _mipFilter) {
    flatbuffers::WriteScalar(&mipFilter_, static_cast<int8_t>(_mipFilter));
  }
  AddressMode addressModeU() const {
    return static_cast<AddressMode>(flatbuffers::EndianScalar(addressModeU_));
  }
  void mutate_addressModeU(AddressMode _addressModeU) {
    flatbuffers::WriteScalar(&addressModeU_, static_cast<int8_t>(_addressModeU));
  }
  AddressMode addressModeV() const {
    return static_cast<AddressMode>(flatbuffers::EndianScalar(addressModeV_));
  }
  void mutate_addressModeV(AddressMode _addressModeV) {
    flatbuffers::WriteScalar(&addressModeV_, static_cast<int8_t>(_addressModeV));
  }
  AddressMode addressModeW() const {
    return static_cast<AddressMode>(flatbuffers::EndianScalar(addressModeW_));
  }
  void mutate_addressModeW(AddressMode _addressModeW) {
    flatbuffers::WriteScalar(&addressModeW_, static_cast<int8_t>(_addressModeW));
  }
  float mipLodBias() const {
    return flatbuffers::EndianScalar(mipLodBias_);
  }
  void mutate_mipLodBias(float _mipLodBias) {
    flatbuffers::WriteScalar(&mipLodBias_, _mipLodBias);
  }
  float maxAnisotropy() const {
    return flatbuffers::EndianScalar(maxAnisotropy_);
  }
  void mutate_maxAnisotropy(float _maxAnisotropy) {
    flatbuffers::WriteScalar(&maxAnisotropy_, _maxAnisotropy);
  }
  float minLod() const {
    return flatbuffers::EndianScalar(minLod_);
  }
  void mutate_minLod(float _minLod) {
    flatbuffers::WriteScalar(&minLod_, _minLod);
  }
  float maxLod() const {
    return flatbuffers::EndianScalar(maxLod_);
  }
  void mutate_maxLod(float _maxLod) {
    flatbuffers::WriteScalar(&maxLod_, _maxLod);
  }
  BorderColor borderColor() const {
    return static_cast<BorderColor>(flatbuffers::EndianScalar(borderColor_));
  }
  void mutate_borderColor(BorderColor _borderColor) {
    flatbuffers::WriteScalar(&borderColor_, static_cast<int8_t>(_borderColor));
  }
  CompareOp compareOp() const {
    return static_cast<CompareOp>(flatbuffers::EndianScalar(compareOp_));
  }
  void mutate_compareOp(CompareOp _compareOp) {
    flatbuffers::WriteScalar(&compareOp_, static_cast<int8_t>(_compareOp));
  }
};
STRUCT_END(SamplerState, 28);

MANUALLY_ALIGNED_STRUCT(4) ArrayInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t length_;
  uint32_t stride_;

 public:
  ArrayInfo() {
    memset(this, 0, sizeof(ArrayInfo));
  }
  ArrayInfo(uint32_t _length, uint32_t _stride)
      : length_(flatbuffers::EndianScalar(_length)),
        stride_(flatbuffers::EndianScalar(_stride)) {
  }
  uint32_t length() const {
    return flatbuffers::EndianScalar(length_);
  }
  void mutate_length(uint32_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
  uint32_t stride() const {
    return flatbuffers::EndianScalar(stride_);
  }
  void mutate_stride(uint32_t _stride) {
    flatbuffers::WriteScalar(&stride_, _stride);
  }
};
STRUCT_END(ArrayInfo, 8);

struct BlendState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOGICALOPENABLE = 4,
    VT_LOGICALOP = 6,
    VT_SEPARATEATTACHMENTBLENDINGENABLE = 8,
    VT_BLENDATTACHMENTS = 10,
    VT_BLENDCONSTANTS = 12
  };
  Bool logicalOpEnable() const {
    return static_cast<Bool>(GetField<int8_t>(VT_LOGICALOPENABLE, 0));
  }
  bool mutate_logicalOpEnable(Bool _logicalOpEnable) {
    return SetField<int8_t>(VT_LOGICALOPENABLE, static_cast<int8_t>(_logicalOpEnable), 0);
  }
  LogicOp logicalOp() const {
    return static_cast<LogicOp>(GetField<int8_t>(VT_LOGICALOP, 0));
  }
  bool mutate_logicalOp(LogicOp _logicalOp) {
    return SetField<int8_t>(VT_LOGICALOP, static_cast<int8_t>(_logicalOp), 0);
  }
  Bool separateAttachmentBlendingEnable() const {
    return static_cast<Bool>(GetField<int8_t>(VT_SEPARATEATTACHMENTBLENDINGENABLE, 0));
  }
  bool mutate_separateAttachmentBlendingEnable(Bool _separateAttachmentBlendingEnable) {
    return SetField<int8_t>(VT_SEPARATEATTACHMENTBLENDINGENABLE, static_cast<int8_t>(_separateAttachmentBlendingEnable), 0);
  }
  const flatbuffers::Vector<const BlendAttachmentState *> *blendAttachments() const {
    return GetPointer<const flatbuffers::Vector<const BlendAttachmentState *> *>(VT_BLENDATTACHMENTS);
  }
  flatbuffers::Vector<const BlendAttachmentState *> *mutable_blendAttachments() {
    return GetPointer<flatbuffers::Vector<const BlendAttachmentState *> *>(VT_BLENDATTACHMENTS);
  }
  const flatbuffers::Vector<float> *blendConstants() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BLENDCONSTANTS);
  }
  flatbuffers::Vector<float> *mutable_blendConstants() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_BLENDCONSTANTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LOGICALOPENABLE) &&
           VerifyField<int8_t>(verifier, VT_LOGICALOP) &&
           VerifyField<int8_t>(verifier, VT_SEPARATEATTACHMENTBLENDINGENABLE) &&
           VerifyOffsetRequired(verifier, VT_BLENDATTACHMENTS) &&
           verifier.Verify(blendAttachments()) &&
           VerifyOffsetRequired(verifier, VT_BLENDCONSTANTS) &&
           verifier.Verify(blendConstants()) &&
           verifier.EndTable();
  }
};

struct BlendStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_logicalOpEnable(Bool logicalOpEnable) {
    fbb_.AddElement<int8_t>(BlendState::VT_LOGICALOPENABLE, static_cast<int8_t>(logicalOpEnable), 0);
  }
  void add_logicalOp(LogicOp logicalOp) {
    fbb_.AddElement<int8_t>(BlendState::VT_LOGICALOP, static_cast<int8_t>(logicalOp), 0);
  }
  void add_separateAttachmentBlendingEnable(Bool separateAttachmentBlendingEnable) {
    fbb_.AddElement<int8_t>(BlendState::VT_SEPARATEATTACHMENTBLENDINGENABLE, static_cast<int8_t>(separateAttachmentBlendingEnable), 0);
  }
  void add_blendAttachments(flatbuffers::Offset<flatbuffers::Vector<const BlendAttachmentState *>> blendAttachments) {
    fbb_.AddOffset(BlendState::VT_BLENDATTACHMENTS, blendAttachments);
  }
  void add_blendConstants(flatbuffers::Offset<flatbuffers::Vector<float>> blendConstants) {
    fbb_.AddOffset(BlendState::VT_BLENDCONSTANTS, blendConstants);
  }
  explicit BlendStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlendStateBuilder &operator=(const BlendStateBuilder &);
  flatbuffers::Offset<BlendState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlendState>(end);
    fbb_.Required(o, BlendState::VT_BLENDATTACHMENTS);
    fbb_.Required(o, BlendState::VT_BLENDCONSTANTS);
    return o;
  }
};

inline flatbuffers::Offset<BlendState> CreateBlendState(
    flatbuffers::FlatBufferBuilder &_fbb,
    Bool logicalOpEnable = Bool::False,
    LogicOp logicalOp = LogicOp::Clear,
    Bool separateAttachmentBlendingEnable = Bool::False,
    flatbuffers::Offset<flatbuffers::Vector<const BlendAttachmentState *>> blendAttachments = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> blendConstants = 0) {
  BlendStateBuilder builder_(_fbb);
  builder_.add_blendConstants(blendConstants);
  builder_.add_blendAttachments(blendAttachments);
  builder_.add_separateAttachmentBlendingEnable(separateAttachmentBlendingEnable);
  builder_.add_logicalOp(logicalOp);
  builder_.add_logicalOpEnable(logicalOpEnable);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlendState> CreateBlendStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Bool logicalOpEnable = Bool::False,
    LogicOp logicalOp = LogicOp::Clear,
    Bool separateAttachmentBlendingEnable = Bool::False,
    const std::vector<const BlendAttachmentState *> *blendAttachments = nullptr,
    const std::vector<float> *blendConstants = nullptr) {
  return mslb::CreateBlendState(
      _fbb,
      logicalOpEnable,
      logicalOp,
      separateAttachmentBlendingEnable,
      blendAttachments ? _fbb.CreateVector<const BlendAttachmentState *>(*blendAttachments) : 0,
      blendConstants ? _fbb.CreateVector<float>(*blendConstants) : 0);
}

struct RenderState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RASTERIZATIONSTATE = 4,
    VT_MULTISAMPLESTATE = 6,
    VT_DEPTHSTENCILSTATE = 8,
    VT_BLENDSTATE = 10,
    VT_PATCHCONTROLPOINTS = 12
  };
  const RasterizationState *rasterizationState() const {
    return GetStruct<const RasterizationState *>(VT_RASTERIZATIONSTATE);
  }
  RasterizationState *mutable_rasterizationState() {
    return GetStruct<RasterizationState *>(VT_RASTERIZATIONSTATE);
  }
  const MultisampleState *multisampleState() const {
    return GetStruct<const MultisampleState *>(VT_MULTISAMPLESTATE);
  }
  MultisampleState *mutable_multisampleState() {
    return GetStruct<MultisampleState *>(VT_MULTISAMPLESTATE);
  }
  const DepthStencilState *depthStencilState() const {
    return GetStruct<const DepthStencilState *>(VT_DEPTHSTENCILSTATE);
  }
  DepthStencilState *mutable_depthStencilState() {
    return GetStruct<DepthStencilState *>(VT_DEPTHSTENCILSTATE);
  }
  const BlendState *blendState() const {
    return GetPointer<const BlendState *>(VT_BLENDSTATE);
  }
  BlendState *mutable_blendState() {
    return GetPointer<BlendState *>(VT_BLENDSTATE);
  }
  uint32_t patchControlPoints() const {
    return GetField<uint32_t>(VT_PATCHCONTROLPOINTS, 0);
  }
  bool mutate_patchControlPoints(uint32_t _patchControlPoints) {
    return SetField<uint32_t>(VT_PATCHCONTROLPOINTS, _patchControlPoints, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<RasterizationState>(verifier, VT_RASTERIZATIONSTATE) &&
           VerifyFieldRequired<MultisampleState>(verifier, VT_MULTISAMPLESTATE) &&
           VerifyFieldRequired<DepthStencilState>(verifier, VT_DEPTHSTENCILSTATE) &&
           VerifyOffsetRequired(verifier, VT_BLENDSTATE) &&
           verifier.VerifyTable(blendState()) &&
           VerifyField<uint32_t>(verifier, VT_PATCHCONTROLPOINTS) &&
           verifier.EndTable();
  }
};

struct RenderStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rasterizationState(const RasterizationState *rasterizationState) {
    fbb_.AddStruct(RenderState::VT_RASTERIZATIONSTATE, rasterizationState);
  }
  void add_multisampleState(const MultisampleState *multisampleState) {
    fbb_.AddStruct(RenderState::VT_MULTISAMPLESTATE, multisampleState);
  }
  void add_depthStencilState(const DepthStencilState *depthStencilState) {
    fbb_.AddStruct(RenderState::VT_DEPTHSTENCILSTATE, depthStencilState);
  }
  void add_blendState(flatbuffers::Offset<BlendState> blendState) {
    fbb_.AddOffset(RenderState::VT_BLENDSTATE, blendState);
  }
  void add_patchControlPoints(uint32_t patchControlPoints) {
    fbb_.AddElement<uint32_t>(RenderState::VT_PATCHCONTROLPOINTS, patchControlPoints, 0);
  }
  explicit RenderStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RenderStateBuilder &operator=(const RenderStateBuilder &);
  flatbuffers::Offset<RenderState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderState>(end);
    fbb_.Required(o, RenderState::VT_RASTERIZATIONSTATE);
    fbb_.Required(o, RenderState::VT_MULTISAMPLESTATE);
    fbb_.Required(o, RenderState::VT_DEPTHSTENCILSTATE);
    fbb_.Required(o, RenderState::VT_BLENDSTATE);
    return o;
  }
};

inline flatbuffers::Offset<RenderState> CreateRenderState(
    flatbuffers::FlatBufferBuilder &_fbb,
    const RasterizationState *rasterizationState = 0,
    const MultisampleState *multisampleState = 0,
    const DepthStencilState *depthStencilState = 0,
    flatbuffers::Offset<BlendState> blendState = 0,
    uint32_t patchControlPoints = 0) {
  RenderStateBuilder builder_(_fbb);
  builder_.add_patchControlPoints(patchControlPoints);
  builder_.add_blendState(blendState);
  builder_.add_depthStencilState(depthStencilState);
  builder_.add_multisampleState(multisampleState);
  builder_.add_rasterizationState(rasterizationState);
  return builder_.Finish();
}

struct StructMember FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_OFFSET = 6,
    VT_SIZE = 8,
    VT_TYPE = 10,
    VT_STRUCTINDEX = 12,
    VT_ARRAYELEMENTS = 14,
    VT_ROWMAJOR = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  bool mutate_offset(uint32_t _offset) {
    return SetField<uint32_t>(VT_OFFSET, _offset, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  Type type() const {
    return static_cast<Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool mutate_type(Type _type) {
    return SetField<uint8_t>(VT_TYPE, static_cast<uint8_t>(_type), 0);
  }
  uint32_t structIndex() const {
    return GetField<uint32_t>(VT_STRUCTINDEX, 0);
  }
  bool mutate_structIndex(uint32_t _structIndex) {
    return SetField<uint32_t>(VT_STRUCTINDEX, _structIndex, 0);
  }
  const flatbuffers::Vector<const ArrayInfo *> *arrayElements() const {
    return GetPointer<const flatbuffers::Vector<const ArrayInfo *> *>(VT_ARRAYELEMENTS);
  }
  flatbuffers::Vector<const ArrayInfo *> *mutable_arrayElements() {
    return GetPointer<flatbuffers::Vector<const ArrayInfo *> *>(VT_ARRAYELEMENTS);
  }
  bool rowMajor() const {
    return GetField<uint8_t>(VT_ROWMAJOR, 0) != 0;
  }
  bool mutate_rowMajor(bool _rowMajor) {
    return SetField<uint8_t>(VT_ROWMAJOR, static_cast<uint8_t>(_rowMajor), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_STRUCTINDEX) &&
           VerifyOffset(verifier, VT_ARRAYELEMENTS) &&
           verifier.Verify(arrayElements()) &&
           VerifyField<uint8_t>(verifier, VT_ROWMAJOR) &&
           verifier.EndTable();
  }
};

struct StructMemberBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(StructMember::VT_NAME, name);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(StructMember::VT_OFFSET, offset, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(StructMember::VT_SIZE, size, 0);
  }
  void add_type(Type type) {
    fbb_.AddElement<uint8_t>(StructMember::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_structIndex(uint32_t structIndex) {
    fbb_.AddElement<uint32_t>(StructMember::VT_STRUCTINDEX, structIndex, 0);
  }
  void add_arrayElements(flatbuffers::Offset<flatbuffers::Vector<const ArrayInfo *>> arrayElements) {
    fbb_.AddOffset(StructMember::VT_ARRAYELEMENTS, arrayElements);
  }
  void add_rowMajor(bool rowMajor) {
    fbb_.AddElement<uint8_t>(StructMember::VT_ROWMAJOR, static_cast<uint8_t>(rowMajor), 0);
  }
  explicit StructMemberBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StructMemberBuilder &operator=(const StructMemberBuilder &);
  flatbuffers::Offset<StructMember> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StructMember>(end);
    fbb_.Required(o, StructMember::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<StructMember> CreateStructMember(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t offset = 0,
    uint32_t size = 0,
    Type type = Type::Float,
    uint32_t structIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<const ArrayInfo *>> arrayElements = 0,
    bool rowMajor = false) {
  StructMemberBuilder builder_(_fbb);
  builder_.add_arrayElements(arrayElements);
  builder_.add_structIndex(structIndex);
  builder_.add_size(size);
  builder_.add_offset(offset);
  builder_.add_name(name);
  builder_.add_rowMajor(rowMajor);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<StructMember> CreateStructMemberDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t offset = 0,
    uint32_t size = 0,
    Type type = Type::Float,
    uint32_t structIndex = 0,
    const std::vector<const ArrayInfo *> *arrayElements = nullptr,
    bool rowMajor = false) {
  return mslb::CreateStructMember(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      offset,
      size,
      type,
      structIndex,
      arrayElements ? _fbb.CreateVector<const ArrayInfo *>(*arrayElements) : 0,
      rowMajor);
}

struct Struct FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_SIZE = 6,
    VT_MEMBERS = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<StructMember>> *members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StructMember>> *>(VT_MEMBERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<StructMember>> *mutable_members() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<StructMember>> *>(VT_MEMBERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           VerifyOffsetRequired(verifier, VT_MEMBERS) &&
           verifier.Verify(members()) &&
           verifier.VerifyVectorOfTables(members()) &&
           verifier.EndTable();
  }
};

struct StructBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Struct::VT_NAME, name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Struct::VT_SIZE, size, 0);
  }
  void add_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StructMember>>> members) {
    fbb_.AddOffset(Struct::VT_MEMBERS, members);
  }
  explicit StructBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StructBuilder &operator=(const StructBuilder &);
  flatbuffers::Offset<Struct> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Struct>(end);
    fbb_.Required(o, Struct::VT_NAME);
    fbb_.Required(o, Struct::VT_MEMBERS);
    return o;
  }
};

inline flatbuffers::Offset<Struct> CreateStruct(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t size = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StructMember>>> members = 0) {
  StructBuilder builder_(_fbb);
  builder_.add_members(members);
  builder_.add_size(size);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Struct> CreateStructDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t size = 0,
    const std::vector<flatbuffers::Offset<StructMember>> *members = nullptr) {
  return mslb::CreateStruct(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      size,
      members ? _fbb.CreateVector<flatbuffers::Offset<StructMember>>(*members) : 0);
}

struct Uniform FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_UNIFORMTYPE = 6,
    VT_TYPE = 8,
    VT_STRUCTINDEX = 10,
    VT_ARRAYELEMENTS = 12,
    VT_DESCRIPTORSET = 14,
    VT_BINDING = 16,
    VT_INPUTATTACHMENTINDEX = 18,
    VT_SAMPLERINDEX = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  UniformType uniformType() const {
    return static_cast<UniformType>(GetField<uint8_t>(VT_UNIFORMTYPE, 0));
  }
  bool mutate_uniformType(UniformType _uniformType) {
    return SetField<uint8_t>(VT_UNIFORMTYPE, static_cast<uint8_t>(_uniformType), 0);
  }
  Type type() const {
    return static_cast<Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool mutate_type(Type _type) {
    return SetField<uint8_t>(VT_TYPE, static_cast<uint8_t>(_type), 0);
  }
  uint32_t structIndex() const {
    return GetField<uint32_t>(VT_STRUCTINDEX, 0);
  }
  bool mutate_structIndex(uint32_t _structIndex) {
    return SetField<uint32_t>(VT_STRUCTINDEX, _structIndex, 0);
  }
  const flatbuffers::Vector<const ArrayInfo *> *arrayElements() const {
    return GetPointer<const flatbuffers::Vector<const ArrayInfo *> *>(VT_ARRAYELEMENTS);
  }
  flatbuffers::Vector<const ArrayInfo *> *mutable_arrayElements() {
    return GetPointer<flatbuffers::Vector<const ArrayInfo *> *>(VT_ARRAYELEMENTS);
  }
  uint32_t descriptorSet() const {
    return GetField<uint32_t>(VT_DESCRIPTORSET, 0);
  }
  bool mutate_descriptorSet(uint32_t _descriptorSet) {
    return SetField<uint32_t>(VT_DESCRIPTORSET, _descriptorSet, 0);
  }
  uint32_t binding() const {
    return GetField<uint32_t>(VT_BINDING, 0);
  }
  bool mutate_binding(uint32_t _binding) {
    return SetField<uint32_t>(VT_BINDING, _binding, 0);
  }
  uint32_t inputAttachmentIndex() const {
    return GetField<uint32_t>(VT_INPUTATTACHMENTINDEX, 0);
  }
  bool mutate_inputAttachmentIndex(uint32_t _inputAttachmentIndex) {
    return SetField<uint32_t>(VT_INPUTATTACHMENTINDEX, _inputAttachmentIndex, 0);
  }
  uint32_t samplerIndex() const {
    return GetField<uint32_t>(VT_SAMPLERINDEX, 0);
  }
  bool mutate_samplerIndex(uint32_t _samplerIndex) {
    return SetField<uint32_t>(VT_SAMPLERINDEX, _samplerIndex, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_UNIFORMTYPE) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_STRUCTINDEX) &&
           VerifyOffset(verifier, VT_ARRAYELEMENTS) &&
           verifier.Verify(arrayElements()) &&
           VerifyField<uint32_t>(verifier, VT_DESCRIPTORSET) &&
           VerifyField<uint32_t>(verifier, VT_BINDING) &&
           VerifyField<uint32_t>(verifier, VT_INPUTATTACHMENTINDEX) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLERINDEX) &&
           verifier.EndTable();
  }
};

struct UniformBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Uniform::VT_NAME, name);
  }
  void add_uniformType(UniformType uniformType) {
    fbb_.AddElement<uint8_t>(Uniform::VT_UNIFORMTYPE, static_cast<uint8_t>(uniformType), 0);
  }
  void add_type(Type type) {
    fbb_.AddElement<uint8_t>(Uniform::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_structIndex(uint32_t structIndex) {
    fbb_.AddElement<uint32_t>(Uniform::VT_STRUCTINDEX, structIndex, 0);
  }
  void add_arrayElements(flatbuffers::Offset<flatbuffers::Vector<const ArrayInfo *>> arrayElements) {
    fbb_.AddOffset(Uniform::VT_ARRAYELEMENTS, arrayElements);
  }
  void add_descriptorSet(uint32_t descriptorSet) {
    fbb_.AddElement<uint32_t>(Uniform::VT_DESCRIPTORSET, descriptorSet, 0);
  }
  void add_binding(uint32_t binding) {
    fbb_.AddElement<uint32_t>(Uniform::VT_BINDING, binding, 0);
  }
  void add_inputAttachmentIndex(uint32_t inputAttachmentIndex) {
    fbb_.AddElement<uint32_t>(Uniform::VT_INPUTATTACHMENTINDEX, inputAttachmentIndex, 0);
  }
  void add_samplerIndex(uint32_t samplerIndex) {
    fbb_.AddElement<uint32_t>(Uniform::VT_SAMPLERINDEX, samplerIndex, 0);
  }
  explicit UniformBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniformBuilder &operator=(const UniformBuilder &);
  flatbuffers::Offset<Uniform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uniform>(end);
    fbb_.Required(o, Uniform::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Uniform> CreateUniform(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    UniformType uniformType = UniformType::PushConstant,
    Type type = Type::Float,
    uint32_t structIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<const ArrayInfo *>> arrayElements = 0,
    uint32_t descriptorSet = 0,
    uint32_t binding = 0,
    uint32_t inputAttachmentIndex = 0,
    uint32_t samplerIndex = 0) {
  UniformBuilder builder_(_fbb);
  builder_.add_samplerIndex(samplerIndex);
  builder_.add_inputAttachmentIndex(inputAttachmentIndex);
  builder_.add_binding(binding);
  builder_.add_descriptorSet(descriptorSet);
  builder_.add_arrayElements(arrayElements);
  builder_.add_structIndex(structIndex);
  builder_.add_name(name);
  builder_.add_type(type);
  builder_.add_uniformType(uniformType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uniform> CreateUniformDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    UniformType uniformType = UniformType::PushConstant,
    Type type = Type::Float,
    uint32_t structIndex = 0,
    const std::vector<const ArrayInfo *> *arrayElements = nullptr,
    uint32_t descriptorSet = 0,
    uint32_t binding = 0,
    uint32_t inputAttachmentIndex = 0,
    uint32_t samplerIndex = 0) {
  return mslb::CreateUniform(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      uniformType,
      type,
      structIndex,
      arrayElements ? _fbb.CreateVector<const ArrayInfo *>(*arrayElements) : 0,
      descriptorSet,
      binding,
      inputAttachmentIndex,
      samplerIndex);
}

struct Attribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_ARRAYELEMENTS = 8,
    VT_LOCATION = 10,
    VT_COMPONENT = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  Type type() const {
    return static_cast<Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool mutate_type(Type _type) {
    return SetField<uint8_t>(VT_TYPE, static_cast<uint8_t>(_type), 0);
  }
  const flatbuffers::Vector<uint32_t> *arrayElements() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ARRAYELEMENTS);
  }
  flatbuffers::Vector<uint32_t> *mutable_arrayElements() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_ARRAYELEMENTS);
  }
  uint32_t location() const {
    return GetField<uint32_t>(VT_LOCATION, 0);
  }
  bool mutate_location(uint32_t _location) {
    return SetField<uint32_t>(VT_LOCATION, _location, 0);
  }
  uint32_t component() const {
    return GetField<uint32_t>(VT_COMPONENT, 0);
  }
  bool mutate_component(uint32_t _component) {
    return SetField<uint32_t>(VT_COMPONENT, _component, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ARRAYELEMENTS) &&
           verifier.Verify(arrayElements()) &&
           VerifyField<uint32_t>(verifier, VT_LOCATION) &&
           VerifyField<uint32_t>(verifier, VT_COMPONENT) &&
           verifier.EndTable();
  }
};

struct AttributeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Attribute::VT_NAME, name);
  }
  void add_type(Type type) {
    fbb_.AddElement<uint8_t>(Attribute::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_arrayElements(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> arrayElements) {
    fbb_.AddOffset(Attribute::VT_ARRAYELEMENTS, arrayElements);
  }
  void add_location(uint32_t location) {
    fbb_.AddElement<uint32_t>(Attribute::VT_LOCATION, location, 0);
  }
  void add_component(uint32_t component) {
    fbb_.AddElement<uint32_t>(Attribute::VT_COMPONENT, component, 0);
  }
  explicit AttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeBuilder &operator=(const AttributeBuilder &);
  flatbuffers::Offset<Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attribute>(end);
    fbb_.Required(o, Attribute::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Attribute> CreateAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Type type = Type::Float,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> arrayElements = 0,
    uint32_t location = 0,
    uint32_t component = 0) {
  AttributeBuilder builder_(_fbb);
  builder_.add_component(component);
  builder_.add_location(location);
  builder_.add_arrayElements(arrayElements);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attribute> CreateAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    Type type = Type::Float,
    const std::vector<uint32_t> *arrayElements = nullptr,
    uint32_t location = 0,
    uint32_t component = 0) {
  return mslb::CreateAttribute(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      type,
      arrayElements ? _fbb.CreateVector<uint32_t>(*arrayElements) : 0,
      location,
      component);
}

struct FragmentOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_LOCATION = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  uint32_t location() const {
    return GetField<uint32_t>(VT_LOCATION, 0);
  }
  bool mutate_location(uint32_t _location) {
    return SetField<uint32_t>(VT_LOCATION, _location, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<uint32_t>(verifier, VT_LOCATION) &&
           verifier.EndTable();
  }
};

struct FragmentOutputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FragmentOutput::VT_NAME, name);
  }
  void add_location(uint32_t location) {
    fbb_.AddElement<uint32_t>(FragmentOutput::VT_LOCATION, location, 0);
  }
  explicit FragmentOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FragmentOutputBuilder &operator=(const FragmentOutputBuilder &);
  flatbuffers::Offset<FragmentOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FragmentOutput>(end);
    fbb_.Required(o, FragmentOutput::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<FragmentOutput> CreateFragmentOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t location = 0) {
  FragmentOutputBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FragmentOutput> CreateFragmentOutputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t location = 0) {
  return mslb::CreateFragmentOutput(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      location);
}

struct Shader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SHADER = 4,
    VT_UNIFORMIDS = 6
  };
  uint32_t shader() const {
    return GetField<uint32_t>(VT_SHADER, 0);
  }
  bool mutate_shader(uint32_t _shader) {
    return SetField<uint32_t>(VT_SHADER, _shader, 0);
  }
  const flatbuffers::Vector<uint32_t> *uniformIds() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_UNIFORMIDS);
  }
  flatbuffers::Vector<uint32_t> *mutable_uniformIds() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_UNIFORMIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SHADER) &&
           VerifyOffset(verifier, VT_UNIFORMIDS) &&
           verifier.Verify(uniformIds()) &&
           verifier.EndTable();
  }
};

struct ShaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shader(uint32_t shader) {
    fbb_.AddElement<uint32_t>(Shader::VT_SHADER, shader, 0);
  }
  void add_uniformIds(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> uniformIds) {
    fbb_.AddOffset(Shader::VT_UNIFORMIDS, uniformIds);
  }
  explicit ShaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderBuilder &operator=(const ShaderBuilder &);
  flatbuffers::Offset<Shader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shader>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shader> CreateShader(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t shader = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> uniformIds = 0) {
  ShaderBuilder builder_(_fbb);
  builder_.add_uniformIds(uniformIds);
  builder_.add_shader(shader);
  return builder_.Finish();
}

inline flatbuffers::Offset<Shader> CreateShaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t shader = 0,
    const std::vector<uint32_t> *uniformIds = nullptr) {
  return mslb::CreateShader(
      _fbb,
      shader,
      uniformIds ? _fbb.CreateVector<uint32_t>(*uniformIds) : 0);
}

struct Pipeline FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_STRUCTS = 6,
    VT_SAMPLERSTATES = 8,
    VT_UNIFORMS = 10,
    VT_ATTRIBUTES = 12,
    VT_FRAGMENTOUTPUTS = 14,
    VT_PUSHCONSTANTSTRUCT = 16,
    VT_RENDERSTATE = 18,
    VT_SHADERS = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Struct>> *structs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Struct>> *>(VT_STRUCTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Struct>> *mutable_structs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Struct>> *>(VT_STRUCTS);
  }
  const flatbuffers::Vector<const SamplerState *> *samplerStates() const {
    return GetPointer<const flatbuffers::Vector<const SamplerState *> *>(VT_SAMPLERSTATES);
  }
  flatbuffers::Vector<const SamplerState *> *mutable_samplerStates() {
    return GetPointer<flatbuffers::Vector<const SamplerState *> *>(VT_SAMPLERSTATES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Uniform>> *uniforms() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Uniform>> *>(VT_UNIFORMS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Uniform>> *mutable_uniforms() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Uniform>> *>(VT_UNIFORMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Attribute>> *attributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Attribute>> *>(VT_ATTRIBUTES);
  }
  flatbuffers::Vector<flatbuffers::Offset<Attribute>> *mutable_attributes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Attribute>> *>(VT_ATTRIBUTES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FragmentOutput>> *fragmentOutputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FragmentOutput>> *>(VT_FRAGMENTOUTPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<FragmentOutput>> *mutable_fragmentOutputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<FragmentOutput>> *>(VT_FRAGMENTOUTPUTS);
  }
  uint32_t pushConstantStruct() const {
    return GetField<uint32_t>(VT_PUSHCONSTANTSTRUCT, 0);
  }
  bool mutate_pushConstantStruct(uint32_t _pushConstantStruct) {
    return SetField<uint32_t>(VT_PUSHCONSTANTSTRUCT, _pushConstantStruct, 0);
  }
  const RenderState *renderState() const {
    return GetPointer<const RenderState *>(VT_RENDERSTATE);
  }
  RenderState *mutable_renderState() {
    return GetPointer<RenderState *>(VT_RENDERSTATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Shader>> *shaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Shader>> *>(VT_SHADERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<Shader>> *mutable_shaders() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Shader>> *>(VT_SHADERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffsetRequired(verifier, VT_STRUCTS) &&
           verifier.Verify(structs()) &&
           verifier.VerifyVectorOfTables(structs()) &&
           VerifyOffsetRequired(verifier, VT_SAMPLERSTATES) &&
           verifier.Verify(samplerStates()) &&
           VerifyOffsetRequired(verifier, VT_UNIFORMS) &&
           verifier.Verify(uniforms()) &&
           verifier.VerifyVectorOfTables(uniforms()) &&
           VerifyOffsetRequired(verifier, VT_ATTRIBUTES) &&
           verifier.Verify(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyOffsetRequired(verifier, VT_FRAGMENTOUTPUTS) &&
           verifier.Verify(fragmentOutputs()) &&
           verifier.VerifyVectorOfTables(fragmentOutputs()) &&
           VerifyField<uint32_t>(verifier, VT_PUSHCONSTANTSTRUCT) &&
           VerifyOffset(verifier, VT_RENDERSTATE) &&
           verifier.VerifyTable(renderState()) &&
           VerifyOffsetRequired(verifier, VT_SHADERS) &&
           verifier.Verify(shaders()) &&
           verifier.VerifyVectorOfTables(shaders()) &&
           verifier.EndTable();
  }
};

struct PipelineBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Pipeline::VT_NAME, name);
  }
  void add_structs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Struct>>> structs) {
    fbb_.AddOffset(Pipeline::VT_STRUCTS, structs);
  }
  void add_samplerStates(flatbuffers::Offset<flatbuffers::Vector<const SamplerState *>> samplerStates) {
    fbb_.AddOffset(Pipeline::VT_SAMPLERSTATES, samplerStates);
  }
  void add_uniforms(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Uniform>>> uniforms) {
    fbb_.AddOffset(Pipeline::VT_UNIFORMS, uniforms);
  }
  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attribute>>> attributes) {
    fbb_.AddOffset(Pipeline::VT_ATTRIBUTES, attributes);
  }
  void add_fragmentOutputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FragmentOutput>>> fragmentOutputs) {
    fbb_.AddOffset(Pipeline::VT_FRAGMENTOUTPUTS, fragmentOutputs);
  }
  void add_pushConstantStruct(uint32_t pushConstantStruct) {
    fbb_.AddElement<uint32_t>(Pipeline::VT_PUSHCONSTANTSTRUCT, pushConstantStruct, 0);
  }
  void add_renderState(flatbuffers::Offset<RenderState> renderState) {
    fbb_.AddOffset(Pipeline::VT_RENDERSTATE, renderState);
  }
  void add_shaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Shader>>> shaders) {
    fbb_.AddOffset(Pipeline::VT_SHADERS, shaders);
  }
  explicit PipelineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PipelineBuilder &operator=(const PipelineBuilder &);
  flatbuffers::Offset<Pipeline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pipeline>(end);
    fbb_.Required(o, Pipeline::VT_NAME);
    fbb_.Required(o, Pipeline::VT_STRUCTS);
    fbb_.Required(o, Pipeline::VT_SAMPLERSTATES);
    fbb_.Required(o, Pipeline::VT_UNIFORMS);
    fbb_.Required(o, Pipeline::VT_ATTRIBUTES);
    fbb_.Required(o, Pipeline::VT_FRAGMENTOUTPUTS);
    fbb_.Required(o, Pipeline::VT_SHADERS);
    return o;
  }
};

inline flatbuffers::Offset<Pipeline> CreatePipeline(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Struct>>> structs = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SamplerState *>> samplerStates = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Uniform>>> uniforms = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attribute>>> attributes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FragmentOutput>>> fragmentOutputs = 0,
    uint32_t pushConstantStruct = 0,
    flatbuffers::Offset<RenderState> renderState = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Shader>>> shaders = 0) {
  PipelineBuilder builder_(_fbb);
  builder_.add_shaders(shaders);
  builder_.add_renderState(renderState);
  builder_.add_pushConstantStruct(pushConstantStruct);
  builder_.add_fragmentOutputs(fragmentOutputs);
  builder_.add_attributes(attributes);
  builder_.add_uniforms(uniforms);
  builder_.add_samplerStates(samplerStates);
  builder_.add_structs(structs);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pipeline> CreatePipelineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<Struct>> *structs = nullptr,
    const std::vector<const SamplerState *> *samplerStates = nullptr,
    const std::vector<flatbuffers::Offset<Uniform>> *uniforms = nullptr,
    const std::vector<flatbuffers::Offset<Attribute>> *attributes = nullptr,
    const std::vector<flatbuffers::Offset<FragmentOutput>> *fragmentOutputs = nullptr,
    uint32_t pushConstantStruct = 0,
    flatbuffers::Offset<RenderState> renderState = 0,
    const std::vector<flatbuffers::Offset<Shader>> *shaders = nullptr) {
  return mslb::CreatePipeline(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      structs ? _fbb.CreateVector<flatbuffers::Offset<Struct>>(*structs) : 0,
      samplerStates ? _fbb.CreateVector<const SamplerState *>(*samplerStates) : 0,
      uniforms ? _fbb.CreateVector<flatbuffers::Offset<Uniform>>(*uniforms) : 0,
      attributes ? _fbb.CreateVector<flatbuffers::Offset<Attribute>>(*attributes) : 0,
      fragmentOutputs ? _fbb.CreateVector<flatbuffers::Offset<FragmentOutput>>(*fragmentOutputs) : 0,
      pushConstantStruct,
      renderState,
      shaders ? _fbb.CreateVector<flatbuffers::Offset<Shader>>(*shaders) : 0);
}

struct ShaderData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct ShaderDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ShaderData::VT_DATA, data);
  }
  explicit ShaderDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShaderDataBuilder &operator=(const ShaderDataBuilder &);
  flatbuffers::Offset<ShaderData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderData>(end);
    fbb_.Required(o, ShaderData::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<ShaderData> CreateShaderData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ShaderDataBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShaderData> CreateShaderDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  return mslb::CreateShaderData(
      _fbb,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

struct Module FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_TARGETID = 6,
    VT_TARGETVERSION = 8,
    VT_ADJUSTABLEBINDINGS = 10,
    VT_PIPELINES = 12,
    VT_SHADERS = 14,
    VT_SHAREDDATA = 16
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  uint32_t targetId() const {
    return GetField<uint32_t>(VT_TARGETID, 0);
  }
  bool mutate_targetId(uint32_t _targetId) {
    return SetField<uint32_t>(VT_TARGETID, _targetId, 0);
  }
  uint32_t targetVersion() const {
    return GetField<uint32_t>(VT_TARGETVERSION, 0);
  }
  bool mutate_targetVersion(uint32_t _targetVersion) {
    return SetField<uint32_t>(VT_TARGETVERSION, _targetVersion, 0);
  }
  bool adjustableBindings() const {
    return GetField<uint8_t>(VT_ADJUSTABLEBINDINGS, 0) != 0;
  }
  bool mutate_adjustableBindings(bool _adjustableBindings) {
    return SetField<uint8_t>(VT_ADJUSTABLEBINDINGS, static_cast<uint8_t>(_adjustableBindings), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pipeline>> *pipelines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pipeline>> *>(VT_PIPELINES);
  }
  flatbuffers::Vector<flatbuffers::Offset<Pipeline>> *mutable_pipelines() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<Pipeline>> *>(VT_PIPELINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShaderData>> *shaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShaderData>> *>(VT_SHADERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<ShaderData>> *mutable_shaders() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<ShaderData>> *>(VT_SHADERS);
  }
  const flatbuffers::Vector<uint8_t> *sharedData() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SHAREDDATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_sharedData() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SHAREDDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_TARGETID) &&
           VerifyField<uint32_t>(verifier, VT_TARGETVERSION) &&
           VerifyField<uint8_t>(verifier, VT_ADJUSTABLEBINDINGS) &&
           VerifyOffsetRequired(verifier, VT_PIPELINES) &&
           verifier.Verify(pipelines()) &&
           verifier.VerifyVectorOfTables(pipelines()) &&
           VerifyOffsetRequired(verifier, VT_SHADERS) &&
           verifier.Verify(shaders()) &&
           verifier.VerifyVectorOfTables(shaders()) &&
           VerifyOffsetRequired(verifier, VT_SHAREDDATA) &&
           verifier.Verify(sharedData()) &&
           verifier.EndTable();
  }
};

struct ModuleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Module::VT_VERSION, version, 0);
  }
  void add_targetId(uint32_t targetId) {
    fbb_.AddElement<uint32_t>(Module::VT_TARGETID, targetId, 0);
  }
  void add_targetVersion(uint32_t targetVersion) {
    fbb_.AddElement<uint32_t>(Module::VT_TARGETVERSION, targetVersion, 0);
  }
  void add_adjustableBindings(bool adjustableBindings) {
    fbb_.AddElement<uint8_t>(Module::VT_ADJUSTABLEBINDINGS, static_cast<uint8_t>(adjustableBindings), 0);
  }
  void add_pipelines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pipeline>>> pipelines) {
    fbb_.AddOffset(Module::VT_PIPELINES, pipelines);
  }
  void add_shaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderData>>> shaders) {
    fbb_.AddOffset(Module::VT_SHADERS, shaders);
  }
  void add_sharedData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sharedData) {
    fbb_.AddOffset(Module::VT_SHAREDDATA, sharedData);
  }
  explicit ModuleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModuleBuilder &operator=(const ModuleBuilder &);
  flatbuffers::Offset<Module> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Module>(end);
    fbb_.Required(o, Module::VT_PIPELINES);
    fbb_.Required(o, Module::VT_SHADERS);
    fbb_.Required(o, Module::VT_SHAREDDATA);
    return o;
  }
};

inline flatbuffers::Offset<Module> CreateModule(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    uint32_t targetId = 0,
    uint32_t targetVersion = 0,
    bool adjustableBindings = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pipeline>>> pipelines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShaderData>>> shaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sharedData = 0) {
  ModuleBuilder builder_(_fbb);
  builder_.add_sharedData(sharedData);
  builder_.add_shaders(shaders);
  builder_.add_pipelines(pipelines);
  builder_.add_targetVersion(targetVersion);
  builder_.add_targetId(targetId);
  builder_.add_version(version);
  builder_.add_adjustableBindings(adjustableBindings);
  return builder_.Finish();
}

inline flatbuffers::Offset<Module> CreateModuleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    uint32_t targetId = 0,
    uint32_t targetVersion = 0,
    bool adjustableBindings = false,
    const std::vector<flatbuffers::Offset<Pipeline>> *pipelines = nullptr,
    const std::vector<flatbuffers::Offset<ShaderData>> *shaders = nullptr,
    const std::vector<uint8_t> *sharedData = nullptr) {
  return mslb::CreateModule(
      _fbb,
      version,
      targetId,
      targetVersion,
      adjustableBindings,
      pipelines ? _fbb.CreateVector<flatbuffers::Offset<Pipeline>>(*pipelines) : 0,
      shaders ? _fbb.CreateVector<flatbuffers::Offset<ShaderData>>(*shaders) : 0,
      sharedData ? _fbb.CreateVector<uint8_t>(*sharedData) : 0);
}

inline const mslb::Module *GetModule(const void *buf) {
  return flatbuffers::GetRoot<mslb::Module>(buf);
}

inline Module *GetMutableModule(void *buf) {
  return flatbuffers::GetMutableRoot<Module>(buf);
}

inline bool VerifyModuleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mslb::Module>(nullptr);
}

inline void FinishModuleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mslb::Module> root) {
  fbb.Finish(root);
}

}  // namespace mslb

#endif  // FLATBUFFERS_GENERATED_MSLB_MSLB_H_
