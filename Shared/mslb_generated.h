// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MSLB_MSLB_H_
#define FLATBUFFERS_GENERATED_MSLB_MSLB_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 22 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace mslb {

struct RasterizationState;

struct MultisampleState;

struct StencilOpState;

struct DepthStencilState;

struct BlendAttachmentState;

struct BlendState;
struct BlendStateBuilder;

struct RenderState;
struct RenderStateBuilder;

struct SamplerState;

struct ArrayInfo;

struct StructMember;
struct StructMemberBuilder;

struct Struct;
struct StructBuilder;

struct Uniform;
struct UniformBuilder;

struct Attribute;
struct AttributeBuilder;

struct FragmentOutput;
struct FragmentOutputBuilder;

struct Shader;
struct ShaderBuilder;

struct ComputeLocalSize;

struct Pipeline;
struct PipelineBuilder;

struct ShaderData;
struct ShaderDataBuilder;

struct Module;
struct ModuleBuilder;

enum class Stage : uint8_t {
  Vertex = 0,
  TessellationControl = 1,
  TessellationEvaluation = 2,
  Geometry = 3,
  Fragment = 4,
  Compute = 5,
  MIN = Vertex,
  MAX = Compute
};

inline const Stage (&EnumValuesStage())[6] {
  static const Stage values[] = {
    Stage::Vertex,
    Stage::TessellationControl,
    Stage::TessellationEvaluation,
    Stage::Geometry,
    Stage::Fragment,
    Stage::Compute
  };
  return values;
}

inline const char * const *EnumNamesStage() {
  static const char * const names[7] = {
    "Vertex",
    "TessellationControl",
    "TessellationEvaluation",
    "Geometry",
    "Fragment",
    "Compute",
    nullptr
  };
  return names;
}

inline const char *EnumNameStage(Stage e) {
  if (flatbuffers::IsOutRange(e, Stage::Vertex, Stage::Compute)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStage()[index];
}

enum class Type : uint8_t {
  Float = 0,
  Vec2 = 1,
  Vec3 = 2,
  Vec4 = 3,
  Double = 4,
  DVec2 = 5,
  DVec3 = 6,
  DVec4 = 7,
  Int = 8,
  IVec2 = 9,
  IVec3 = 10,
  IVec4 = 11,
  UInt = 12,
  UVec2 = 13,
  UVec3 = 14,
  UVec4 = 15,
  Bool = 16,
  BVec2 = 17,
  BVec3 = 18,
  BVec4 = 19,
  Mat2 = 20,
  Mat3 = 21,
  Mat4 = 22,
  Mat2x3 = 23,
  Mat2x4 = 24,
  Mat3x2 = 25,
  Mat3x4 = 26,
  Mat4x2 = 27,
  Mat4x3 = 28,
  DMat2 = 29,
  DMat3 = 30,
  DMat4 = 31,
  DMat2x3 = 32,
  DMat2x4 = 33,
  DMat3x2 = 34,
  DMat3x4 = 35,
  DMat4x2 = 36,
  DMat4x3 = 37,
  Sampler1D = 38,
  Sampler2D = 39,
  Sampler3D = 40,
  SamplerCube = 41,
  Sampler1DShadow = 42,
  Sampler2DShadow = 43,
  Sampler1DArray = 44,
  Sampler2DArray = 45,
  Sampler1DArrayShadow = 46,
  Sampler2DArrayShadow = 47,
  Sampler2DMS = 48,
  Sampler2DMSArray = 49,
  SamplerCubeShadow = 50,
  SamplerBuffer = 51,
  Sampler2DRect = 52,
  Sampler2DRectShadow = 53,
  ISampler1D = 54,
  ISampler2D = 55,
  ISampler3D = 56,
  ISamplerCube = 57,
  ISampler1DArray = 58,
  ISampler2DArray = 59,
  ISampler2DMS = 60,
  ISampler2DMSArray = 61,
  ISampler2DRect = 62,
  USampler1D = 63,
  USampler2D = 64,
  USampler3D = 65,
  USamplerCube = 66,
  USampler1DArray = 67,
  USampler2DArray = 68,
  USampler2DMS = 69,
  USampler2DMSArray = 70,
  USampler2DRect = 71,
  Image1D = 72,
  Image2D = 73,
  Image3D = 74,
  ImageCube = 75,
  Image1DArray = 76,
  Image2DArray = 77,
  Image2DMS = 78,
  Image2DMSArray = 79,
  ImageBuffer = 80,
  Image2DRect = 81,
  IImage1D = 82,
  IImage2D = 83,
  IImage3D = 84,
  IImageCube = 85,
  IImage1DArray = 86,
  IImage2DArray = 87,
  IImage2DMS = 88,
  IImage2DMSArray = 89,
  IImage2DRect = 90,
  UImage1D = 91,
  UImage2D = 92,
  UImage3D = 93,
  UImageCube = 94,
  UImage1DArray = 95,
  UImage2DArray = 96,
  UImage2DMS = 97,
  UImage2DMSArray = 98,
  UImage2DRect = 99,
  SubpassInput = 100,
  SubpassInputMS = 101,
  ISubpassInput = 102,
  ISubpassInputMS = 103,
  USubpassInput = 104,
  USubpassInputMS = 105,
  Struct = 106,
  MIN = Float,
  MAX = Struct
};

inline const Type (&EnumValuesType())[107] {
  static const Type values[] = {
    Type::Float,
    Type::Vec2,
    Type::Vec3,
    Type::Vec4,
    Type::Double,
    Type::DVec2,
    Type::DVec3,
    Type::DVec4,
    Type::Int,
    Type::IVec2,
    Type::IVec3,
    Type::IVec4,
    Type::UInt,
    Type::UVec2,
    Type::UVec3,
    Type::UVec4,
    Type::Bool,
    Type::BVec2,
    Type::BVec3,
    Type::BVec4,
    Type::Mat2,
    Type::Mat3,
    Type::Mat4,
    Type::Mat2x3,
    Type::Mat2x4,
    Type::Mat3x2,
    Type::Mat3x4,
    Type::Mat4x2,
    Type::Mat4x3,
    Type::DMat2,
    Type::DMat3,
    Type::DMat4,
    Type::DMat2x3,
    Type::DMat2x4,
    Type::DMat3x2,
    Type::DMat3x4,
    Type::DMat4x2,
    Type::DMat4x3,
    Type::Sampler1D,
    Type::Sampler2D,
    Type::Sampler3D,
    Type::SamplerCube,
    Type::Sampler1DShadow,
    Type::Sampler2DShadow,
    Type::Sampler1DArray,
    Type::Sampler2DArray,
    Type::Sampler1DArrayShadow,
    Type::Sampler2DArrayShadow,
    Type::Sampler2DMS,
    Type::Sampler2DMSArray,
    Type::SamplerCubeShadow,
    Type::SamplerBuffer,
    Type::Sampler2DRect,
    Type::Sampler2DRectShadow,
    Type::ISampler1D,
    Type::ISampler2D,
    Type::ISampler3D,
    Type::ISamplerCube,
    Type::ISampler1DArray,
    Type::ISampler2DArray,
    Type::ISampler2DMS,
    Type::ISampler2DMSArray,
    Type::ISampler2DRect,
    Type::USampler1D,
    Type::USampler2D,
    Type::USampler3D,
    Type::USamplerCube,
    Type::USampler1DArray,
    Type::USampler2DArray,
    Type::USampler2DMS,
    Type::USampler2DMSArray,
    Type::USampler2DRect,
    Type::Image1D,
    Type::Image2D,
    Type::Image3D,
    Type::ImageCube,
    Type::Image1DArray,
    Type::Image2DArray,
    Type::Image2DMS,
    Type::Image2DMSArray,
    Type::ImageBuffer,
    Type::Image2DRect,
    Type::IImage1D,
    Type::IImage2D,
    Type::IImage3D,
    Type::IImageCube,
    Type::IImage1DArray,
    Type::IImage2DArray,
    Type::IImage2DMS,
    Type::IImage2DMSArray,
    Type::IImage2DRect,
    Type::UImage1D,
    Type::UImage2D,
    Type::UImage3D,
    Type::UImageCube,
    Type::UImage1DArray,
    Type::UImage2DArray,
    Type::UImage2DMS,
    Type::UImage2DMSArray,
    Type::UImage2DRect,
    Type::SubpassInput,
    Type::SubpassInputMS,
    Type::ISubpassInput,
    Type::ISubpassInputMS,
    Type::USubpassInput,
    Type::USubpassInputMS,
    Type::Struct
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[108] = {
    "Float",
    "Vec2",
    "Vec3",
    "Vec4",
    "Double",
    "DVec2",
    "DVec3",
    "DVec4",
    "Int",
    "IVec2",
    "IVec3",
    "IVec4",
    "UInt",
    "UVec2",
    "UVec3",
    "UVec4",
    "Bool",
    "BVec2",
    "BVec3",
    "BVec4",
    "Mat2",
    "Mat3",
    "Mat4",
    "Mat2x3",
    "Mat2x4",
    "Mat3x2",
    "Mat3x4",
    "Mat4x2",
    "Mat4x3",
    "DMat2",
    "DMat3",
    "DMat4",
    "DMat2x3",
    "DMat2x4",
    "DMat3x2",
    "DMat3x4",
    "DMat4x2",
    "DMat4x3",
    "Sampler1D",
    "Sampler2D",
    "Sampler3D",
    "SamplerCube",
    "Sampler1DShadow",
    "Sampler2DShadow",
    "Sampler1DArray",
    "Sampler2DArray",
    "Sampler1DArrayShadow",
    "Sampler2DArrayShadow",
    "Sampler2DMS",
    "Sampler2DMSArray",
    "SamplerCubeShadow",
    "SamplerBuffer",
    "Sampler2DRect",
    "Sampler2DRectShadow",
    "ISampler1D",
    "ISampler2D",
    "ISampler3D",
    "ISamplerCube",
    "ISampler1DArray",
    "ISampler2DArray",
    "ISampler2DMS",
    "ISampler2DMSArray",
    "ISampler2DRect",
    "USampler1D",
    "USampler2D",
    "USampler3D",
    "USamplerCube",
    "USampler1DArray",
    "USampler2DArray",
    "USampler2DMS",
    "USampler2DMSArray",
    "USampler2DRect",
    "Image1D",
    "Image2D",
    "Image3D",
    "ImageCube",
    "Image1DArray",
    "Image2DArray",
    "Image2DMS",
    "Image2DMSArray",
    "ImageBuffer",
    "Image2DRect",
    "IImage1D",
    "IImage2D",
    "IImage3D",
    "IImageCube",
    "IImage1DArray",
    "IImage2DArray",
    "IImage2DMS",
    "IImage2DMSArray",
    "IImage2DRect",
    "UImage1D",
    "UImage2D",
    "UImage3D",
    "UImageCube",
    "UImage1DArray",
    "UImage2DArray",
    "UImage2DMS",
    "UImage2DMSArray",
    "UImage2DRect",
    "SubpassInput",
    "SubpassInputMS",
    "ISubpassInput",
    "ISubpassInputMS",
    "USubpassInput",
    "USubpassInputMS",
    "Struct",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type::Float, Type::Struct)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

enum class UniformType : uint8_t {
  PushConstant = 0,
  Block = 1,
  BlockBuffer = 2,
  Image = 3,
  SampledImage = 4,
  SubpassInput = 5,
  MIN = PushConstant,
  MAX = SubpassInput
};

inline const UniformType (&EnumValuesUniformType())[6] {
  static const UniformType values[] = {
    UniformType::PushConstant,
    UniformType::Block,
    UniformType::BlockBuffer,
    UniformType::Image,
    UniformType::SampledImage,
    UniformType::SubpassInput
  };
  return values;
}

inline const char * const *EnumNamesUniformType() {
  static const char * const names[7] = {
    "PushConstant",
    "Block",
    "BlockBuffer",
    "Image",
    "SampledImage",
    "SubpassInput",
    nullptr
  };
  return names;
}

inline const char *EnumNameUniformType(UniformType e) {
  if (flatbuffers::IsOutRange(e, UniformType::PushConstant, UniformType::SubpassInput)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUniformType()[index];
}

enum class Bool : int8_t {
  Unset = -1,
  False = 0,
  True = 1,
  MIN = Unset,
  MAX = True
};

inline const Bool (&EnumValuesBool())[3] {
  static const Bool values[] = {
    Bool::Unset,
    Bool::False,
    Bool::True
  };
  return values;
}

inline const char * const *EnumNamesBool() {
  static const char * const names[4] = {
    "Unset",
    "False",
    "True",
    nullptr
  };
  return names;
}

inline const char *EnumNameBool(Bool e) {
  if (flatbuffers::IsOutRange(e, Bool::Unset, Bool::True)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(Bool::Unset);
  return EnumNamesBool()[index];
}

enum class PolygonMode : int8_t {
  Unset = -1,
  Fill = 0,
  Line = 1,
  Point = 2,
  MIN = Unset,
  MAX = Point
};

inline const PolygonMode (&EnumValuesPolygonMode())[4] {
  static const PolygonMode values[] = {
    PolygonMode::Unset,
    PolygonMode::Fill,
    PolygonMode::Line,
    PolygonMode::Point
  };
  return values;
}

inline const char * const *EnumNamesPolygonMode() {
  static const char * const names[5] = {
    "Unset",
    "Fill",
    "Line",
    "Point",
    nullptr
  };
  return names;
}

inline const char *EnumNamePolygonMode(PolygonMode e) {
  if (flatbuffers::IsOutRange(e, PolygonMode::Unset, PolygonMode::Point)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(PolygonMode::Unset);
  return EnumNamesPolygonMode()[index];
}

enum class CullMode : int8_t {
  Unset = -1,
  None = 0,
  Front = 1,
  Back = 2,
  FrontAndBack = 3,
  MIN = Unset,
  MAX = FrontAndBack
};

inline const CullMode (&EnumValuesCullMode())[5] {
  static const CullMode values[] = {
    CullMode::Unset,
    CullMode::None,
    CullMode::Front,
    CullMode::Back,
    CullMode::FrontAndBack
  };
  return values;
}

inline const char * const *EnumNamesCullMode() {
  static const char * const names[6] = {
    "Unset",
    "None",
    "Front",
    "Back",
    "FrontAndBack",
    nullptr
  };
  return names;
}

inline const char *EnumNameCullMode(CullMode e) {
  if (flatbuffers::IsOutRange(e, CullMode::Unset, CullMode::FrontAndBack)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(CullMode::Unset);
  return EnumNamesCullMode()[index];
}

enum class FrontFace : int8_t {
  Unset = -1,
  CounterClockwise = 0,
  Clockwise = 1,
  MIN = Unset,
  MAX = Clockwise
};

inline const FrontFace (&EnumValuesFrontFace())[3] {
  static const FrontFace values[] = {
    FrontFace::Unset,
    FrontFace::CounterClockwise,
    FrontFace::Clockwise
  };
  return values;
}

inline const char * const *EnumNamesFrontFace() {
  static const char * const names[4] = {
    "Unset",
    "CounterClockwise",
    "Clockwise",
    nullptr
  };
  return names;
}

inline const char *EnumNameFrontFace(FrontFace e) {
  if (flatbuffers::IsOutRange(e, FrontFace::Unset, FrontFace::Clockwise)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(FrontFace::Unset);
  return EnumNamesFrontFace()[index];
}

enum class StencilOp : int8_t {
  Unset = -1,
  Keep = 0,
  Zero = 1,
  Replace = 2,
  IncrementAndClamp = 3,
  DecrementAndClamp = 4,
  Invert = 5,
  IncrementAndWrap = 6,
  DecrementAndWrap = 7,
  MIN = Unset,
  MAX = DecrementAndWrap
};

inline const StencilOp (&EnumValuesStencilOp())[9] {
  static const StencilOp values[] = {
    StencilOp::Unset,
    StencilOp::Keep,
    StencilOp::Zero,
    StencilOp::Replace,
    StencilOp::IncrementAndClamp,
    StencilOp::DecrementAndClamp,
    StencilOp::Invert,
    StencilOp::IncrementAndWrap,
    StencilOp::DecrementAndWrap
  };
  return values;
}

inline const char * const *EnumNamesStencilOp() {
  static const char * const names[10] = {
    "Unset",
    "Keep",
    "Zero",
    "Replace",
    "IncrementAndClamp",
    "DecrementAndClamp",
    "Invert",
    "IncrementAndWrap",
    "DecrementAndWrap",
    nullptr
  };
  return names;
}

inline const char *EnumNameStencilOp(StencilOp e) {
  if (flatbuffers::IsOutRange(e, StencilOp::Unset, StencilOp::DecrementAndWrap)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(StencilOp::Unset);
  return EnumNamesStencilOp()[index];
}

enum class CompareOp : int8_t {
  Unset = -1,
  Never = 0,
  Less = 1,
  Equal = 2,
  LessOrEqual = 3,
  Greater = 4,
  NotEqual = 5,
  GreaterOrEqual = 6,
  Always = 7,
  MIN = Unset,
  MAX = Always
};

inline const CompareOp (&EnumValuesCompareOp())[9] {
  static const CompareOp values[] = {
    CompareOp::Unset,
    CompareOp::Never,
    CompareOp::Less,
    CompareOp::Equal,
    CompareOp::LessOrEqual,
    CompareOp::Greater,
    CompareOp::NotEqual,
    CompareOp::GreaterOrEqual,
    CompareOp::Always
  };
  return values;
}

inline const char * const *EnumNamesCompareOp() {
  static const char * const names[10] = {
    "Unset",
    "Never",
    "Less",
    "Equal",
    "LessOrEqual",
    "Greater",
    "NotEqual",
    "GreaterOrEqual",
    "Always",
    nullptr
  };
  return names;
}

inline const char *EnumNameCompareOp(CompareOp e) {
  if (flatbuffers::IsOutRange(e, CompareOp::Unset, CompareOp::Always)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(CompareOp::Unset);
  return EnumNamesCompareOp()[index];
}

enum class BlendFactor : int8_t {
  Unset = -1,
  Zero = 0,
  One = 1,
  SrcColor = 2,
  OneMinusSrcColor = 3,
  DstColor = 4,
  OneMinusDstColor = 5,
  SrcAlpha = 6,
  OneMinusSrcAlpha = 7,
  DstAlpha = 8,
  OneMinusDstAlpha = 9,
  ConstColor = 10,
  OneMinusConstColor = 11,
  ConstAlpha = 12,
  OneMinusConstAlpha = 13,
  SrcAlphaSaturate = 14,
  Src1Color = 15,
  OneMinusSrc1Color = 16,
  Src1Alpha = 17,
  OneMinusSrc1Alpha = 18,
  MIN = Unset,
  MAX = OneMinusSrc1Alpha
};

inline const BlendFactor (&EnumValuesBlendFactor())[20] {
  static const BlendFactor values[] = {
    BlendFactor::Unset,
    BlendFactor::Zero,
    BlendFactor::One,
    BlendFactor::SrcColor,
    BlendFactor::OneMinusSrcColor,
    BlendFactor::DstColor,
    BlendFactor::OneMinusDstColor,
    BlendFactor::SrcAlpha,
    BlendFactor::OneMinusSrcAlpha,
    BlendFactor::DstAlpha,
    BlendFactor::OneMinusDstAlpha,
    BlendFactor::ConstColor,
    BlendFactor::OneMinusConstColor,
    BlendFactor::ConstAlpha,
    BlendFactor::OneMinusConstAlpha,
    BlendFactor::SrcAlphaSaturate,
    BlendFactor::Src1Color,
    BlendFactor::OneMinusSrc1Color,
    BlendFactor::Src1Alpha,
    BlendFactor::OneMinusSrc1Alpha
  };
  return values;
}

inline const char * const *EnumNamesBlendFactor() {
  static const char * const names[21] = {
    "Unset",
    "Zero",
    "One",
    "SrcColor",
    "OneMinusSrcColor",
    "DstColor",
    "OneMinusDstColor",
    "SrcAlpha",
    "OneMinusSrcAlpha",
    "DstAlpha",
    "OneMinusDstAlpha",
    "ConstColor",
    "OneMinusConstColor",
    "ConstAlpha",
    "OneMinusConstAlpha",
    "SrcAlphaSaturate",
    "Src1Color",
    "OneMinusSrc1Color",
    "Src1Alpha",
    "OneMinusSrc1Alpha",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlendFactor(BlendFactor e) {
  if (flatbuffers::IsOutRange(e, BlendFactor::Unset, BlendFactor::OneMinusSrc1Alpha)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(BlendFactor::Unset);
  return EnumNamesBlendFactor()[index];
}

enum class BlendOp : int8_t {
  Unset = -1,
  Add = 0,
  Subtract = 1,
  ReverseSubtract = 2,
  Min = 3,
  Max = 4,
  MIN = Unset,
  MAX = Max
};

inline const BlendOp (&EnumValuesBlendOp())[6] {
  static const BlendOp values[] = {
    BlendOp::Unset,
    BlendOp::Add,
    BlendOp::Subtract,
    BlendOp::ReverseSubtract,
    BlendOp::Min,
    BlendOp::Max
  };
  return values;
}

inline const char * const *EnumNamesBlendOp() {
  static const char * const names[7] = {
    "Unset",
    "Add",
    "Subtract",
    "ReverseSubtract",
    "Min",
    "Max",
    nullptr
  };
  return names;
}

inline const char *EnumNameBlendOp(BlendOp e) {
  if (flatbuffers::IsOutRange(e, BlendOp::Unset, BlendOp::Max)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(BlendOp::Unset);
  return EnumNamesBlendOp()[index];
}

enum class ColorMask : int8_t {
  Unset = -1,
  None = 0,
  Red = 1,
  Green = 2,
  Blue = 4,
  Alpha = 8,
  MIN = Unset,
  MAX = Alpha
};

inline const ColorMask (&EnumValuesColorMask())[6] {
  static const ColorMask values[] = {
    ColorMask::Unset,
    ColorMask::None,
    ColorMask::Red,
    ColorMask::Green,
    ColorMask::Blue,
    ColorMask::Alpha
  };
  return values;
}

inline const char * const *EnumNamesColorMask() {
  static const char * const names[11] = {
    "Unset",
    "None",
    "Red",
    "Green",
    "",
    "Blue",
    "",
    "",
    "",
    "Alpha",
    nullptr
  };
  return names;
}

inline const char *EnumNameColorMask(ColorMask e) {
  if (flatbuffers::IsOutRange(e, ColorMask::Unset, ColorMask::Alpha)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ColorMask::Unset);
  return EnumNamesColorMask()[index];
}

enum class LogicOp : int8_t {
  Unset = -1,
  Clear = 0,
  And = 1,
  AndReverse = 2,
  Copy = 3,
  AndInverted = 4,
  NoOp = 5,
  Xor = 6,
  Or = 7,
  Nor = 8,
  Equivalent = 9,
  Invert = 10,
  OrReverse = 11,
  CopyInverted = 12,
  OrInverted = 13,
  Nand = 14,
  Set = 15,
  MIN = Unset,
  MAX = Set
};

inline const LogicOp (&EnumValuesLogicOp())[17] {
  static const LogicOp values[] = {
    LogicOp::Unset,
    LogicOp::Clear,
    LogicOp::And,
    LogicOp::AndReverse,
    LogicOp::Copy,
    LogicOp::AndInverted,
    LogicOp::NoOp,
    LogicOp::Xor,
    LogicOp::Or,
    LogicOp::Nor,
    LogicOp::Equivalent,
    LogicOp::Invert,
    LogicOp::OrReverse,
    LogicOp::CopyInverted,
    LogicOp::OrInverted,
    LogicOp::Nand,
    LogicOp::Set
  };
  return values;
}

inline const char * const *EnumNamesLogicOp() {
  static const char * const names[18] = {
    "Unset",
    "Clear",
    "And",
    "AndReverse",
    "Copy",
    "AndInverted",
    "NoOp",
    "Xor",
    "Or",
    "Nor",
    "Equivalent",
    "Invert",
    "OrReverse",
    "CopyInverted",
    "OrInverted",
    "Nand",
    "Set",
    nullptr
  };
  return names;
}

inline const char *EnumNameLogicOp(LogicOp e) {
  if (flatbuffers::IsOutRange(e, LogicOp::Unset, LogicOp::Set)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(LogicOp::Unset);
  return EnumNamesLogicOp()[index];
}

enum class Filter : int8_t {
  Unset = -1,
  Nearest = 0,
  Linear = 1,
  MIN = Unset,
  MAX = Linear
};

inline const Filter (&EnumValuesFilter())[3] {
  static const Filter values[] = {
    Filter::Unset,
    Filter::Nearest,
    Filter::Linear
  };
  return values;
}

inline const char * const *EnumNamesFilter() {
  static const char * const names[4] = {
    "Unset",
    "Nearest",
    "Linear",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilter(Filter e) {
  if (flatbuffers::IsOutRange(e, Filter::Unset, Filter::Linear)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(Filter::Unset);
  return EnumNamesFilter()[index];
}

enum class MipFilter : int8_t {
  Unset = -1,
  None = 0,
  Nearest = 1,
  Linear = 2,
  Anisotropic = 3,
  MIN = Unset,
  MAX = Anisotropic
};

inline const MipFilter (&EnumValuesMipFilter())[5] {
  static const MipFilter values[] = {
    MipFilter::Unset,
    MipFilter::None,
    MipFilter::Nearest,
    MipFilter::Linear,
    MipFilter::Anisotropic
  };
  return values;
}

inline const char * const *EnumNamesMipFilter() {
  static const char * const names[6] = {
    "Unset",
    "None",
    "Nearest",
    "Linear",
    "Anisotropic",
    nullptr
  };
  return names;
}

inline const char *EnumNameMipFilter(MipFilter e) {
  if (flatbuffers::IsOutRange(e, MipFilter::Unset, MipFilter::Anisotropic)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(MipFilter::Unset);
  return EnumNamesMipFilter()[index];
}

enum class AddressMode : int8_t {
  Unset = -1,
  Repeat = 0,
  MirroredRepeat = 1,
  ClampToEdge = 2,
  ClampToBorder = 3,
  MirrorOnce = 4,
  MIN = Unset,
  MAX = MirrorOnce
};

inline const AddressMode (&EnumValuesAddressMode())[6] {
  static const AddressMode values[] = {
    AddressMode::Unset,
    AddressMode::Repeat,
    AddressMode::MirroredRepeat,
    AddressMode::ClampToEdge,
    AddressMode::ClampToBorder,
    AddressMode::MirrorOnce
  };
  return values;
}

inline const char * const *EnumNamesAddressMode() {
  static const char * const names[7] = {
    "Unset",
    "Repeat",
    "MirroredRepeat",
    "ClampToEdge",
    "ClampToBorder",
    "MirrorOnce",
    nullptr
  };
  return names;
}

inline const char *EnumNameAddressMode(AddressMode e) {
  if (flatbuffers::IsOutRange(e, AddressMode::Unset, AddressMode::MirrorOnce)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(AddressMode::Unset);
  return EnumNamesAddressMode()[index];
}

enum class BorderColor : int8_t {
  Unset = -1,
  TransparentBlack = 0,
  TransparentIntZero = 1,
  OpaqueBlack = 2,
  OpaqueIntZero = 3,
  OpaqueWhite = 4,
  OpaqueIntOne = 5,
  MIN = Unset,
  MAX = OpaqueIntOne
};

inline const BorderColor (&EnumValuesBorderColor())[7] {
  static const BorderColor values[] = {
    BorderColor::Unset,
    BorderColor::TransparentBlack,
    BorderColor::TransparentIntZero,
    BorderColor::OpaqueBlack,
    BorderColor::OpaqueIntZero,
    BorderColor::OpaqueWhite,
    BorderColor::OpaqueIntOne
  };
  return values;
}

inline const char * const *EnumNamesBorderColor() {
  static const char * const names[8] = {
    "Unset",
    "TransparentBlack",
    "TransparentIntZero",
    "OpaqueBlack",
    "OpaqueIntZero",
    "OpaqueWhite",
    "OpaqueIntOne",
    nullptr
  };
  return names;
}

inline const char *EnumNameBorderColor(BorderColor e) {
  if (flatbuffers::IsOutRange(e, BorderColor::Unset, BorderColor::OpaqueIntOne)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(BorderColor::Unset);
  return EnumNamesBorderColor()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) RasterizationState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t depthClampEnable_;
  int8_t rasterizerDiscardEnable_;
  int8_t polygonMode_;
  int8_t cullMode_;
  int8_t frontFace_;
  int8_t depthBiasEnable_;
  int16_t padding0__;
  float depthBiasConstantFactor_;
  float depthBiasClamp_;
  float depthBiasSlopeFactor_;
  float lineWidth_;

 public:
  RasterizationState()
      : depthClampEnable_(0),
        rasterizerDiscardEnable_(0),
        polygonMode_(0),
        cullMode_(0),
        frontFace_(0),
        depthBiasEnable_(0),
        padding0__(0),
        depthBiasConstantFactor_(0),
        depthBiasClamp_(0),
        depthBiasSlopeFactor_(0),
        lineWidth_(0) {
    (void)padding0__;
  }
  RasterizationState(mslb::Bool _depthClampEnable, mslb::Bool _rasterizerDiscardEnable, mslb::PolygonMode _polygonMode, mslb::CullMode _cullMode, mslb::FrontFace _frontFace, mslb::Bool _depthBiasEnable, float _depthBiasConstantFactor, float _depthBiasClamp, float _depthBiasSlopeFactor, float _lineWidth)
      : depthClampEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthClampEnable))),
        rasterizerDiscardEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_rasterizerDiscardEnable))),
        polygonMode_(flatbuffers::EndianScalar(static_cast<int8_t>(_polygonMode))),
        cullMode_(flatbuffers::EndianScalar(static_cast<int8_t>(_cullMode))),
        frontFace_(flatbuffers::EndianScalar(static_cast<int8_t>(_frontFace))),
        depthBiasEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthBiasEnable))),
        padding0__(0),
        depthBiasConstantFactor_(flatbuffers::EndianScalar(_depthBiasConstantFactor)),
        depthBiasClamp_(flatbuffers::EndianScalar(_depthBiasClamp)),
        depthBiasSlopeFactor_(flatbuffers::EndianScalar(_depthBiasSlopeFactor)),
        lineWidth_(flatbuffers::EndianScalar(_lineWidth)) {
    (void)padding0__;
  }
  mslb::Bool depthClampEnable() const {
    return static_cast<mslb::Bool>(flatbuffers::EndianScalar(depthClampEnable_));
  }
  void mutate_depthClampEnable(mslb::Bool _depthClampEnable) {
    flatbuffers::WriteScalar(&depthClampEnable_, static_cast<int8_t>(_depthClampEnable));
  }
  mslb::Bool rasterizerDiscardEnable() const {
    return static_cast<mslb::Bool>(flatbuffers::EndianScalar(rasterizerDiscardEnable_));
  }
  void mutate_rasterizerDiscardEnable(mslb::Bool _rasterizerDiscardEnable) {
    flatbuffers::WriteScalar(&rasterizerDiscardEnable_, static_cast<int8_t>(_rasterizerDiscardEnable));
  }
  mslb::PolygonMode polygonMode() const {
    return static_cast<mslb::PolygonMode>(flatbuffers::EndianScalar(polygonMode_));
  }
  void mutate_polygonMode(mslb::PolygonMode _polygonMode) {
    flatbuffers::WriteScalar(&polygonMode_, static_cast<int8_t>(_polygonMode));
  }
  mslb::CullMode cullMode() const {
    return static_cast<mslb::CullMode>(flatbuffers::EndianScalar(cullMode_));
  }
  void mutate_cullMode(mslb::CullMode _cullMode) {
    flatbuffers::WriteScalar(&cullMode_, static_cast<int8_t>(_cullMode));
  }
  mslb::FrontFace frontFace() const {
    return static_cast<mslb::FrontFace>(flatbuffers::EndianScalar(frontFace_));
  }
  void mutate_frontFace(mslb::FrontFace _frontFace) {
    flatbuffers::WriteScalar(&frontFace_, static_cast<int8_t>(_frontFace));
  }
  mslb::Bool depthBiasEnable() const {
    return static_cast<mslb::Bool>(flatbuffers::EndianScalar(depthBiasEnable_));
  }
  void mutate_depthBiasEnable(mslb::Bool _depthBiasEnable) {
    flatbuffers::WriteScalar(&depthBiasEnable_, static_cast<int8_t>(_depthBiasEnable));
  }
  float depthBiasConstantFactor() const {
    return flatbuffers::EndianScalar(depthBiasConstantFactor_);
  }
  void mutate_depthBiasConstantFactor(float _depthBiasConstantFactor) {
    flatbuffers::WriteScalar(&depthBiasConstantFactor_, _depthBiasConstantFactor);
  }
  float depthBiasClamp() const {
    return flatbuffers::EndianScalar(depthBiasClamp_);
  }
  void mutate_depthBiasClamp(float _depthBiasClamp) {
    flatbuffers::WriteScalar(&depthBiasClamp_, _depthBiasClamp);
  }
  float depthBiasSlopeFactor() const {
    return flatbuffers::EndianScalar(depthBiasSlopeFactor_);
  }
  void mutate_depthBiasSlopeFactor(float _depthBiasSlopeFactor) {
    flatbuffers::WriteScalar(&depthBiasSlopeFactor_, _depthBiasSlopeFactor);
  }
  float lineWidth() const {
    return flatbuffers::EndianScalar(lineWidth_);
  }
  void mutate_lineWidth(float _lineWidth) {
    flatbuffers::WriteScalar(&lineWidth_, _lineWidth);
  }
};
FLATBUFFERS_STRUCT_END(RasterizationState, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MultisampleState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t sampleShadingEnable_;
  int8_t padding0__;  int16_t padding1__;
  float minSampleShading_;
  uint32_t sampleMask_;
  int8_t alphaToCoverageEnable_;
  int8_t alphaToOneEnable_;
  int16_t padding2__;

 public:
  MultisampleState()
      : sampleShadingEnable_(0),
        padding0__(0),
        padding1__(0),
        minSampleShading_(0),
        sampleMask_(0),
        alphaToCoverageEnable_(0),
        alphaToOneEnable_(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  MultisampleState(mslb::Bool _sampleShadingEnable, float _minSampleShading, uint32_t _sampleMask, mslb::Bool _alphaToCoverageEnable, mslb::Bool _alphaToOneEnable)
      : sampleShadingEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_sampleShadingEnable))),
        padding0__(0),
        padding1__(0),
        minSampleShading_(flatbuffers::EndianScalar(_minSampleShading)),
        sampleMask_(flatbuffers::EndianScalar(_sampleMask)),
        alphaToCoverageEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_alphaToCoverageEnable))),
        alphaToOneEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_alphaToOneEnable))),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  mslb::Bool sampleShadingEnable() const {
    return static_cast<mslb::Bool>(flatbuffers::EndianScalar(sampleShadingEnable_));
  }
  void mutate_sampleShadingEnable(mslb::Bool _sampleShadingEnable) {
    flatbuffers::WriteScalar(&sampleShadingEnable_, static_cast<int8_t>(_sampleShadingEnable));
  }
  float minSampleShading() const {
    return flatbuffers::EndianScalar(minSampleShading_);
  }
  void mutate_minSampleShading(float _minSampleShading) {
    flatbuffers::WriteScalar(&minSampleShading_, _minSampleShading);
  }
  uint32_t sampleMask() const {
    return flatbuffers::EndianScalar(sampleMask_);
  }
  void mutate_sampleMask(uint32_t _sampleMask) {
    flatbuffers::WriteScalar(&sampleMask_, _sampleMask);
  }
  mslb::Bool alphaToCoverageEnable() const {
    return static_cast<mslb::Bool>(flatbuffers::EndianScalar(alphaToCoverageEnable_));
  }
  void mutate_alphaToCoverageEnable(mslb::Bool _alphaToCoverageEnable) {
    flatbuffers::WriteScalar(&alphaToCoverageEnable_, static_cast<int8_t>(_alphaToCoverageEnable));
  }
  mslb::Bool alphaToOneEnable() const {
    return static_cast<mslb::Bool>(flatbuffers::EndianScalar(alphaToOneEnable_));
  }
  void mutate_alphaToOneEnable(mslb::Bool _alphaToOneEnable) {
    flatbuffers::WriteScalar(&alphaToOneEnable_, static_cast<int8_t>(_alphaToOneEnable));
  }
};
FLATBUFFERS_STRUCT_END(MultisampleState, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) StencilOpState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t failOp_;
  int8_t passOp_;
  int8_t depthFailOp_;
  int8_t compareOp_;
  uint32_t compareMask_;
  uint32_t writeMask_;
  uint32_t reference_;

 public:
  StencilOpState()
      : failOp_(0),
        passOp_(0),
        depthFailOp_(0),
        compareOp_(0),
        compareMask_(0),
        writeMask_(0),
        reference_(0) {
  }
  StencilOpState(mslb::StencilOp _failOp, mslb::StencilOp _passOp, mslb::StencilOp _depthFailOp, mslb::CompareOp _compareOp, uint32_t _compareMask, uint32_t _writeMask, uint32_t _reference)
      : failOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_failOp))),
        passOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_passOp))),
        depthFailOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthFailOp))),
        compareOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_compareOp))),
        compareMask_(flatbuffers::EndianScalar(_compareMask)),
        writeMask_(flatbuffers::EndianScalar(_writeMask)),
        reference_(flatbuffers::EndianScalar(_reference)) {
  }
  mslb::StencilOp failOp() const {
    return static_cast<mslb::StencilOp>(flatbuffers::EndianScalar(failOp_));
  }
  void mutate_failOp(mslb::StencilOp _failOp) {
    flatbuffers::WriteScalar(&failOp_, static_cast<int8_t>(_failOp));
  }
  mslb::StencilOp passOp() const {
    return static_cast<mslb::StencilOp>(flatbuffers::EndianScalar(passOp_));
  }
  void mutate_passOp(mslb::StencilOp _passOp) {
    flatbuffers::WriteScalar(&passOp_, static_cast<int8_t>(_passOp));
  }
  mslb::StencilOp depthFailOp() const {
    return static_cast<mslb::StencilOp>(flatbuffers::EndianScalar(depthFailOp_));
  }
  void mutate_depthFailOp(mslb::StencilOp _depthFailOp) {
    flatbuffers::WriteScalar(&depthFailOp_, static_cast<int8_t>(_depthFailOp));
  }
  mslb::CompareOp compareOp() const {
    return static_cast<mslb::CompareOp>(flatbuffers::EndianScalar(compareOp_));
  }
  void mutate_compareOp(mslb::CompareOp _compareOp) {
    flatbuffers::WriteScalar(&compareOp_, static_cast<int8_t>(_compareOp));
  }
  uint32_t compareMask() const {
    return flatbuffers::EndianScalar(compareMask_);
  }
  void mutate_compareMask(uint32_t _compareMask) {
    flatbuffers::WriteScalar(&compareMask_, _compareMask);
  }
  uint32_t writeMask() const {
    return flatbuffers::EndianScalar(writeMask_);
  }
  void mutate_writeMask(uint32_t _writeMask) {
    flatbuffers::WriteScalar(&writeMask_, _writeMask);
  }
  uint32_t reference() const {
    return flatbuffers::EndianScalar(reference_);
  }
  void mutate_reference(uint32_t _reference) {
    flatbuffers::WriteScalar(&reference_, _reference);
  }
};
FLATBUFFERS_STRUCT_END(StencilOpState, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) DepthStencilState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t depthTestEnable_;
  int8_t depthWriteEnable_;
  int8_t depthCompareOp_;
  int8_t depthBoundsTestEnable_;
  int8_t stencilTestEnable_;
  int8_t padding0__;  int16_t padding1__;
  mslb::StencilOpState frontStencil_;
  mslb::StencilOpState backStencil_;
  float minDepthBounds_;
  float maxDepthBounds_;

 public:
  DepthStencilState()
      : depthTestEnable_(0),
        depthWriteEnable_(0),
        depthCompareOp_(0),
        depthBoundsTestEnable_(0),
        stencilTestEnable_(0),
        padding0__(0),
        padding1__(0),
        frontStencil_(),
        backStencil_(),
        minDepthBounds_(0),
        maxDepthBounds_(0) {
    (void)padding0__;
    (void)padding1__;
  }
  DepthStencilState(mslb::Bool _depthTestEnable, mslb::Bool _depthWriteEnable, mslb::CompareOp _depthCompareOp, mslb::Bool _depthBoundsTestEnable, mslb::Bool _stencilTestEnable, const mslb::StencilOpState &_frontStencil, const mslb::StencilOpState &_backStencil, float _minDepthBounds, float _maxDepthBounds)
      : depthTestEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthTestEnable))),
        depthWriteEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthWriteEnable))),
        depthCompareOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthCompareOp))),
        depthBoundsTestEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_depthBoundsTestEnable))),
        stencilTestEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_stencilTestEnable))),
        padding0__(0),
        padding1__(0),
        frontStencil_(_frontStencil),
        backStencil_(_backStencil),
        minDepthBounds_(flatbuffers::EndianScalar(_minDepthBounds)),
        maxDepthBounds_(flatbuffers::EndianScalar(_maxDepthBounds)) {
    (void)padding0__;
    (void)padding1__;
  }
  mslb::Bool depthTestEnable() const {
    return static_cast<mslb::Bool>(flatbuffers::EndianScalar(depthTestEnable_));
  }
  void mutate_depthTestEnable(mslb::Bool _depthTestEnable) {
    flatbuffers::WriteScalar(&depthTestEnable_, static_cast<int8_t>(_depthTestEnable));
  }
  mslb::Bool depthWriteEnable() const {
    return static_cast<mslb::Bool>(flatbuffers::EndianScalar(depthWriteEnable_));
  }
  void mutate_depthWriteEnable(mslb::Bool _depthWriteEnable) {
    flatbuffers::WriteScalar(&depthWriteEnable_, static_cast<int8_t>(_depthWriteEnable));
  }
  mslb::CompareOp depthCompareOp() const {
    return static_cast<mslb::CompareOp>(flatbuffers::EndianScalar(depthCompareOp_));
  }
  void mutate_depthCompareOp(mslb::CompareOp _depthCompareOp) {
    flatbuffers::WriteScalar(&depthCompareOp_, static_cast<int8_t>(_depthCompareOp));
  }
  mslb::Bool depthBoundsTestEnable() const {
    return static_cast<mslb::Bool>(flatbuffers::EndianScalar(depthBoundsTestEnable_));
  }
  void mutate_depthBoundsTestEnable(mslb::Bool _depthBoundsTestEnable) {
    flatbuffers::WriteScalar(&depthBoundsTestEnable_, static_cast<int8_t>(_depthBoundsTestEnable));
  }
  mslb::Bool stencilTestEnable() const {
    return static_cast<mslb::Bool>(flatbuffers::EndianScalar(stencilTestEnable_));
  }
  void mutate_stencilTestEnable(mslb::Bool _stencilTestEnable) {
    flatbuffers::WriteScalar(&stencilTestEnable_, static_cast<int8_t>(_stencilTestEnable));
  }
  const mslb::StencilOpState &frontStencil() const {
    return frontStencil_;
  }
  mslb::StencilOpState &mutable_frontStencil() {
    return frontStencil_;
  }
  const mslb::StencilOpState &backStencil() const {
    return backStencil_;
  }
  mslb::StencilOpState &mutable_backStencil() {
    return backStencil_;
  }
  float minDepthBounds() const {
    return flatbuffers::EndianScalar(minDepthBounds_);
  }
  void mutate_minDepthBounds(float _minDepthBounds) {
    flatbuffers::WriteScalar(&minDepthBounds_, _minDepthBounds);
  }
  float maxDepthBounds() const {
    return flatbuffers::EndianScalar(maxDepthBounds_);
  }
  void mutate_maxDepthBounds(float _maxDepthBounds) {
    flatbuffers::WriteScalar(&maxDepthBounds_, _maxDepthBounds);
  }
};
FLATBUFFERS_STRUCT_END(DepthStencilState, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) BlendAttachmentState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t blendEnable_;
  int8_t srcColorBlendFactor_;
  int8_t dstColorBlendFactor_;
  int8_t colorBlendOp_;
  int8_t srcAlphaBlendFactor_;
  int8_t dstAlphaBlendFactor_;
  int8_t alphaBlendOp_;
  int8_t colorWriteMask_;

 public:
  BlendAttachmentState()
      : blendEnable_(0),
        srcColorBlendFactor_(0),
        dstColorBlendFactor_(0),
        colorBlendOp_(0),
        srcAlphaBlendFactor_(0),
        dstAlphaBlendFactor_(0),
        alphaBlendOp_(0),
        colorWriteMask_(0) {
  }
  BlendAttachmentState(mslb::Bool _blendEnable, mslb::BlendFactor _srcColorBlendFactor, mslb::BlendFactor _dstColorBlendFactor, mslb::BlendOp _colorBlendOp, mslb::BlendFactor _srcAlphaBlendFactor, mslb::BlendFactor _dstAlphaBlendFactor, mslb::BlendOp _alphaBlendOp, mslb::ColorMask _colorWriteMask)
      : blendEnable_(flatbuffers::EndianScalar(static_cast<int8_t>(_blendEnable))),
        srcColorBlendFactor_(flatbuffers::EndianScalar(static_cast<int8_t>(_srcColorBlendFactor))),
        dstColorBlendFactor_(flatbuffers::EndianScalar(static_cast<int8_t>(_dstColorBlendFactor))),
        colorBlendOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_colorBlendOp))),
        srcAlphaBlendFactor_(flatbuffers::EndianScalar(static_cast<int8_t>(_srcAlphaBlendFactor))),
        dstAlphaBlendFactor_(flatbuffers::EndianScalar(static_cast<int8_t>(_dstAlphaBlendFactor))),
        alphaBlendOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_alphaBlendOp))),
        colorWriteMask_(flatbuffers::EndianScalar(static_cast<int8_t>(_colorWriteMask))) {
  }
  mslb::Bool blendEnable() const {
    return static_cast<mslb::Bool>(flatbuffers::EndianScalar(blendEnable_));
  }
  void mutate_blendEnable(mslb::Bool _blendEnable) {
    flatbuffers::WriteScalar(&blendEnable_, static_cast<int8_t>(_blendEnable));
  }
  mslb::BlendFactor srcColorBlendFactor() const {
    return static_cast<mslb::BlendFactor>(flatbuffers::EndianScalar(srcColorBlendFactor_));
  }
  void mutate_srcColorBlendFactor(mslb::BlendFactor _srcColorBlendFactor) {
    flatbuffers::WriteScalar(&srcColorBlendFactor_, static_cast<int8_t>(_srcColorBlendFactor));
  }
  mslb::BlendFactor dstColorBlendFactor() const {
    return static_cast<mslb::BlendFactor>(flatbuffers::EndianScalar(dstColorBlendFactor_));
  }
  void mutate_dstColorBlendFactor(mslb::BlendFactor _dstColorBlendFactor) {
    flatbuffers::WriteScalar(&dstColorBlendFactor_, static_cast<int8_t>(_dstColorBlendFactor));
  }
  mslb::BlendOp colorBlendOp() const {
    return static_cast<mslb::BlendOp>(flatbuffers::EndianScalar(colorBlendOp_));
  }
  void mutate_colorBlendOp(mslb::BlendOp _colorBlendOp) {
    flatbuffers::WriteScalar(&colorBlendOp_, static_cast<int8_t>(_colorBlendOp));
  }
  mslb::BlendFactor srcAlphaBlendFactor() const {
    return static_cast<mslb::BlendFactor>(flatbuffers::EndianScalar(srcAlphaBlendFactor_));
  }
  void mutate_srcAlphaBlendFactor(mslb::BlendFactor _srcAlphaBlendFactor) {
    flatbuffers::WriteScalar(&srcAlphaBlendFactor_, static_cast<int8_t>(_srcAlphaBlendFactor));
  }
  mslb::BlendFactor dstAlphaBlendFactor() const {
    return static_cast<mslb::BlendFactor>(flatbuffers::EndianScalar(dstAlphaBlendFactor_));
  }
  void mutate_dstAlphaBlendFactor(mslb::BlendFactor _dstAlphaBlendFactor) {
    flatbuffers::WriteScalar(&dstAlphaBlendFactor_, static_cast<int8_t>(_dstAlphaBlendFactor));
  }
  mslb::BlendOp alphaBlendOp() const {
    return static_cast<mslb::BlendOp>(flatbuffers::EndianScalar(alphaBlendOp_));
  }
  void mutate_alphaBlendOp(mslb::BlendOp _alphaBlendOp) {
    flatbuffers::WriteScalar(&alphaBlendOp_, static_cast<int8_t>(_alphaBlendOp));
  }
  mslb::ColorMask colorWriteMask() const {
    return static_cast<mslb::ColorMask>(flatbuffers::EndianScalar(colorWriteMask_));
  }
  void mutate_colorWriteMask(mslb::ColorMask _colorWriteMask) {
    flatbuffers::WriteScalar(&colorWriteMask_, static_cast<int8_t>(_colorWriteMask));
  }
};
FLATBUFFERS_STRUCT_END(BlendAttachmentState, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SamplerState FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t minFilter_;
  int8_t magFilter_;
  int8_t mipFilter_;
  int8_t addressModeU_;
  int8_t addressModeV_;
  int8_t addressModeW_;
  int16_t padding0__;
  float mipLodBias_;
  float maxAnisotropy_;
  float minLod_;
  float maxLod_;
  int8_t borderColor_;
  int8_t compareOp_;
  int16_t padding1__;

 public:
  SamplerState()
      : minFilter_(0),
        magFilter_(0),
        mipFilter_(0),
        addressModeU_(0),
        addressModeV_(0),
        addressModeW_(0),
        padding0__(0),
        mipLodBias_(0),
        maxAnisotropy_(0),
        minLod_(0),
        maxLod_(0),
        borderColor_(0),
        compareOp_(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  SamplerState(mslb::Filter _minFilter, mslb::Filter _magFilter, mslb::MipFilter _mipFilter, mslb::AddressMode _addressModeU, mslb::AddressMode _addressModeV, mslb::AddressMode _addressModeW, float _mipLodBias, float _maxAnisotropy, float _minLod, float _maxLod, mslb::BorderColor _borderColor, mslb::CompareOp _compareOp)
      : minFilter_(flatbuffers::EndianScalar(static_cast<int8_t>(_minFilter))),
        magFilter_(flatbuffers::EndianScalar(static_cast<int8_t>(_magFilter))),
        mipFilter_(flatbuffers::EndianScalar(static_cast<int8_t>(_mipFilter))),
        addressModeU_(flatbuffers::EndianScalar(static_cast<int8_t>(_addressModeU))),
        addressModeV_(flatbuffers::EndianScalar(static_cast<int8_t>(_addressModeV))),
        addressModeW_(flatbuffers::EndianScalar(static_cast<int8_t>(_addressModeW))),
        padding0__(0),
        mipLodBias_(flatbuffers::EndianScalar(_mipLodBias)),
        maxAnisotropy_(flatbuffers::EndianScalar(_maxAnisotropy)),
        minLod_(flatbuffers::EndianScalar(_minLod)),
        maxLod_(flatbuffers::EndianScalar(_maxLod)),
        borderColor_(flatbuffers::EndianScalar(static_cast<int8_t>(_borderColor))),
        compareOp_(flatbuffers::EndianScalar(static_cast<int8_t>(_compareOp))),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  mslb::Filter minFilter() const {
    return static_cast<mslb::Filter>(flatbuffers::EndianScalar(minFilter_));
  }
  void mutate_minFilter(mslb::Filter _minFilter) {
    flatbuffers::WriteScalar(&minFilter_, static_cast<int8_t>(_minFilter));
  }
  mslb::Filter magFilter() const {
    return static_cast<mslb::Filter>(flatbuffers::EndianScalar(magFilter_));
  }
  void mutate_magFilter(mslb::Filter _magFilter) {
    flatbuffers::WriteScalar(&magFilter_, static_cast<int8_t>(_magFilter));
  }
  mslb::MipFilter mipFilter() const {
    return static_cast<mslb::MipFilter>(flatbuffers::EndianScalar(mipFilter_));
  }
  void mutate_mipFilter(mslb::MipFilter _mipFilter) {
    flatbuffers::WriteScalar(&mipFilter_, static_cast<int8_t>(_mipFilter));
  }
  mslb::AddressMode addressModeU() const {
    return static_cast<mslb::AddressMode>(flatbuffers::EndianScalar(addressModeU_));
  }
  void mutate_addressModeU(mslb::AddressMode _addressModeU) {
    flatbuffers::WriteScalar(&addressModeU_, static_cast<int8_t>(_addressModeU));
  }
  mslb::AddressMode addressModeV() const {
    return static_cast<mslb::AddressMode>(flatbuffers::EndianScalar(addressModeV_));
  }
  void mutate_addressModeV(mslb::AddressMode _addressModeV) {
    flatbuffers::WriteScalar(&addressModeV_, static_cast<int8_t>(_addressModeV));
  }
  mslb::AddressMode addressModeW() const {
    return static_cast<mslb::AddressMode>(flatbuffers::EndianScalar(addressModeW_));
  }
  void mutate_addressModeW(mslb::AddressMode _addressModeW) {
    flatbuffers::WriteScalar(&addressModeW_, static_cast<int8_t>(_addressModeW));
  }
  float mipLodBias() const {
    return flatbuffers::EndianScalar(mipLodBias_);
  }
  void mutate_mipLodBias(float _mipLodBias) {
    flatbuffers::WriteScalar(&mipLodBias_, _mipLodBias);
  }
  float maxAnisotropy() const {
    return flatbuffers::EndianScalar(maxAnisotropy_);
  }
  void mutate_maxAnisotropy(float _maxAnisotropy) {
    flatbuffers::WriteScalar(&maxAnisotropy_, _maxAnisotropy);
  }
  float minLod() const {
    return flatbuffers::EndianScalar(minLod_);
  }
  void mutate_minLod(float _minLod) {
    flatbuffers::WriteScalar(&minLod_, _minLod);
  }
  float maxLod() const {
    return flatbuffers::EndianScalar(maxLod_);
  }
  void mutate_maxLod(float _maxLod) {
    flatbuffers::WriteScalar(&maxLod_, _maxLod);
  }
  mslb::BorderColor borderColor() const {
    return static_cast<mslb::BorderColor>(flatbuffers::EndianScalar(borderColor_));
  }
  void mutate_borderColor(mslb::BorderColor _borderColor) {
    flatbuffers::WriteScalar(&borderColor_, static_cast<int8_t>(_borderColor));
  }
  mslb::CompareOp compareOp() const {
    return static_cast<mslb::CompareOp>(flatbuffers::EndianScalar(compareOp_));
  }
  void mutate_compareOp(mslb::CompareOp _compareOp) {
    flatbuffers::WriteScalar(&compareOp_, static_cast<int8_t>(_compareOp));
  }
};
FLATBUFFERS_STRUCT_END(SamplerState, 28);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ArrayInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t length_;
  uint32_t stride_;

 public:
  ArrayInfo()
      : length_(0),
        stride_(0) {
  }
  ArrayInfo(uint32_t _length, uint32_t _stride)
      : length_(flatbuffers::EndianScalar(_length)),
        stride_(flatbuffers::EndianScalar(_stride)) {
  }
  uint32_t length() const {
    return flatbuffers::EndianScalar(length_);
  }
  void mutate_length(uint32_t _length) {
    flatbuffers::WriteScalar(&length_, _length);
  }
  uint32_t stride() const {
    return flatbuffers::EndianScalar(stride_);
  }
  void mutate_stride(uint32_t _stride) {
    flatbuffers::WriteScalar(&stride_, _stride);
  }
};
FLATBUFFERS_STRUCT_END(ArrayInfo, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ComputeLocalSize FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t x_;
  uint32_t y_;
  uint32_t z_;

 public:
  ComputeLocalSize()
      : x_(0),
        y_(0),
        z_(0) {
  }
  ComputeLocalSize(uint32_t _x, uint32_t _y, uint32_t _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  uint32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(uint32_t _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  uint32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(uint32_t _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  uint32_t z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(uint32_t _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
FLATBUFFERS_STRUCT_END(ComputeLocalSize, 12);

struct BlendState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BlendStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOGICALOPENABLE = 4,
    VT_LOGICALOP = 6,
    VT_SEPARATEATTACHMENTBLENDINGENABLE = 8,
    VT_BLENDATTACHMENTS = 10,
    VT_BLENDCONSTANTS = 12
  };
  mslb::Bool logicalOpEnable() const {
    return static_cast<mslb::Bool>(GetField<int8_t>(VT_LOGICALOPENABLE, 0));
  }
  bool mutate_logicalOpEnable(mslb::Bool _logicalOpEnable = static_cast<mslb::Bool>(0)) {
    return SetField<int8_t>(VT_LOGICALOPENABLE, static_cast<int8_t>(_logicalOpEnable), 0);
  }
  mslb::LogicOp logicalOp() const {
    return static_cast<mslb::LogicOp>(GetField<int8_t>(VT_LOGICALOP, 0));
  }
  bool mutate_logicalOp(mslb::LogicOp _logicalOp = static_cast<mslb::LogicOp>(0)) {
    return SetField<int8_t>(VT_LOGICALOP, static_cast<int8_t>(_logicalOp), 0);
  }
  mslb::Bool separateAttachmentBlendingEnable() const {
    return static_cast<mslb::Bool>(GetField<int8_t>(VT_SEPARATEATTACHMENTBLENDINGENABLE, 0));
  }
  bool mutate_separateAttachmentBlendingEnable(mslb::Bool _separateAttachmentBlendingEnable = static_cast<mslb::Bool>(0)) {
    return SetField<int8_t>(VT_SEPARATEATTACHMENTBLENDINGENABLE, static_cast<int8_t>(_separateAttachmentBlendingEnable), 0);
  }
  const flatbuffers::Vector<const mslb::BlendAttachmentState *> *blendAttachments() const {
    return GetPointer<const flatbuffers::Vector<const mslb::BlendAttachmentState *> *>(VT_BLENDATTACHMENTS);
  }
  flatbuffers::Vector<const mslb::BlendAttachmentState *> *mutable_blendAttachments() {
    return GetPointer<flatbuffers::Vector<const mslb::BlendAttachmentState *> *>(VT_BLENDATTACHMENTS);
  }
  const flatbuffers::Vector<float> *blendConstants() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BLENDCONSTANTS);
  }
  flatbuffers::Vector<float> *mutable_blendConstants() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_BLENDCONSTANTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_LOGICALOPENABLE, 1) &&
           VerifyField<int8_t>(verifier, VT_LOGICALOP, 1) &&
           VerifyField<int8_t>(verifier, VT_SEPARATEATTACHMENTBLENDINGENABLE, 1) &&
           VerifyOffsetRequired(verifier, VT_BLENDATTACHMENTS) &&
           verifier.VerifyVector(blendAttachments()) &&
           VerifyOffsetRequired(verifier, VT_BLENDCONSTANTS) &&
           verifier.VerifyVector(blendConstants()) &&
           verifier.EndTable();
  }
};

struct BlendStateBuilder {
  typedef BlendState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_logicalOpEnable(mslb::Bool logicalOpEnable) {
    fbb_.AddElement<int8_t>(BlendState::VT_LOGICALOPENABLE, static_cast<int8_t>(logicalOpEnable), 0);
  }
  void add_logicalOp(mslb::LogicOp logicalOp) {
    fbb_.AddElement<int8_t>(BlendState::VT_LOGICALOP, static_cast<int8_t>(logicalOp), 0);
  }
  void add_separateAttachmentBlendingEnable(mslb::Bool separateAttachmentBlendingEnable) {
    fbb_.AddElement<int8_t>(BlendState::VT_SEPARATEATTACHMENTBLENDINGENABLE, static_cast<int8_t>(separateAttachmentBlendingEnable), 0);
  }
  void add_blendAttachments(flatbuffers::Offset<flatbuffers::Vector<const mslb::BlendAttachmentState *>> blendAttachments) {
    fbb_.AddOffset(BlendState::VT_BLENDATTACHMENTS, blendAttachments);
  }
  void add_blendConstants(flatbuffers::Offset<flatbuffers::Vector<float>> blendConstants) {
    fbb_.AddOffset(BlendState::VT_BLENDCONSTANTS, blendConstants);
  }
  explicit BlendStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BlendState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlendState>(end);
    fbb_.Required(o, BlendState::VT_BLENDATTACHMENTS);
    fbb_.Required(o, BlendState::VT_BLENDCONSTANTS);
    return o;
  }
};

inline flatbuffers::Offset<BlendState> CreateBlendState(
    flatbuffers::FlatBufferBuilder &_fbb,
    mslb::Bool logicalOpEnable = mslb::Bool::False,
    mslb::LogicOp logicalOp = mslb::LogicOp::Clear,
    mslb::Bool separateAttachmentBlendingEnable = mslb::Bool::False,
    flatbuffers::Offset<flatbuffers::Vector<const mslb::BlendAttachmentState *>> blendAttachments = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> blendConstants = 0) {
  BlendStateBuilder builder_(_fbb);
  builder_.add_blendConstants(blendConstants);
  builder_.add_blendAttachments(blendAttachments);
  builder_.add_separateAttachmentBlendingEnable(separateAttachmentBlendingEnable);
  builder_.add_logicalOp(logicalOp);
  builder_.add_logicalOpEnable(logicalOpEnable);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlendState> CreateBlendStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mslb::Bool logicalOpEnable = mslb::Bool::False,
    mslb::LogicOp logicalOp = mslb::LogicOp::Clear,
    mslb::Bool separateAttachmentBlendingEnable = mslb::Bool::False,
    const std::vector<mslb::BlendAttachmentState> *blendAttachments = nullptr,
    const std::vector<float> *blendConstants = nullptr) {
  auto blendAttachments__ = blendAttachments ? _fbb.CreateVectorOfStructs<mslb::BlendAttachmentState>(*blendAttachments) : 0;
  auto blendConstants__ = blendConstants ? _fbb.CreateVector<float>(*blendConstants) : 0;
  return mslb::CreateBlendState(
      _fbb,
      logicalOpEnable,
      logicalOp,
      separateAttachmentBlendingEnable,
      blendAttachments__,
      blendConstants__);
}

struct RenderState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RenderStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RASTERIZATIONSTATE = 4,
    VT_MULTISAMPLESTATE = 6,
    VT_DEPTHSTENCILSTATE = 8,
    VT_BLENDSTATE = 10,
    VT_PATCHCONTROLPOINTS = 12,
    VT_CLIPDISTANCECOUNT = 14,
    VT_CULLDISTANCECOUNT = 16,
    VT_FRAGMENTGROUP = 18
  };
  const mslb::RasterizationState *rasterizationState() const {
    return GetStruct<const mslb::RasterizationState *>(VT_RASTERIZATIONSTATE);
  }
  mslb::RasterizationState *mutable_rasterizationState() {
    return GetStruct<mslb::RasterizationState *>(VT_RASTERIZATIONSTATE);
  }
  const mslb::MultisampleState *multisampleState() const {
    return GetStruct<const mslb::MultisampleState *>(VT_MULTISAMPLESTATE);
  }
  mslb::MultisampleState *mutable_multisampleState() {
    return GetStruct<mslb::MultisampleState *>(VT_MULTISAMPLESTATE);
  }
  const mslb::DepthStencilState *depthStencilState() const {
    return GetStruct<const mslb::DepthStencilState *>(VT_DEPTHSTENCILSTATE);
  }
  mslb::DepthStencilState *mutable_depthStencilState() {
    return GetStruct<mslb::DepthStencilState *>(VT_DEPTHSTENCILSTATE);
  }
  const mslb::BlendState *blendState() const {
    return GetPointer<const mslb::BlendState *>(VT_BLENDSTATE);
  }
  mslb::BlendState *mutable_blendState() {
    return GetPointer<mslb::BlendState *>(VT_BLENDSTATE);
  }
  uint32_t patchControlPoints() const {
    return GetField<uint32_t>(VT_PATCHCONTROLPOINTS, 0);
  }
  bool mutate_patchControlPoints(uint32_t _patchControlPoints = 0) {
    return SetField<uint32_t>(VT_PATCHCONTROLPOINTS, _patchControlPoints, 0);
  }
  uint32_t clipDistanceCount() const {
    return GetField<uint32_t>(VT_CLIPDISTANCECOUNT, 0);
  }
  bool mutate_clipDistanceCount(uint32_t _clipDistanceCount = 0) {
    return SetField<uint32_t>(VT_CLIPDISTANCECOUNT, _clipDistanceCount, 0);
  }
  uint32_t cullDistanceCount() const {
    return GetField<uint32_t>(VT_CULLDISTANCECOUNT, 0);
  }
  bool mutate_cullDistanceCount(uint32_t _cullDistanceCount = 0) {
    return SetField<uint32_t>(VT_CULLDISTANCECOUNT, _cullDistanceCount, 0);
  }
  uint32_t fragmentGroup() const {
    return GetField<uint32_t>(VT_FRAGMENTGROUP, 4294967295);
  }
  bool mutate_fragmentGroup(uint32_t _fragmentGroup = 4294967295) {
    return SetField<uint32_t>(VT_FRAGMENTGROUP, _fragmentGroup, 4294967295);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<mslb::RasterizationState>(verifier, VT_RASTERIZATIONSTATE, 4) &&
           VerifyFieldRequired<mslb::MultisampleState>(verifier, VT_MULTISAMPLESTATE, 4) &&
           VerifyFieldRequired<mslb::DepthStencilState>(verifier, VT_DEPTHSTENCILSTATE, 4) &&
           VerifyOffsetRequired(verifier, VT_BLENDSTATE) &&
           verifier.VerifyTable(blendState()) &&
           VerifyField<uint32_t>(verifier, VT_PATCHCONTROLPOINTS, 4) &&
           VerifyField<uint32_t>(verifier, VT_CLIPDISTANCECOUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_CULLDISTANCECOUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_FRAGMENTGROUP, 4) &&
           verifier.EndTable();
  }
};

struct RenderStateBuilder {
  typedef RenderState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rasterizationState(const mslb::RasterizationState *rasterizationState) {
    fbb_.AddStruct(RenderState::VT_RASTERIZATIONSTATE, rasterizationState);
  }
  void add_multisampleState(const mslb::MultisampleState *multisampleState) {
    fbb_.AddStruct(RenderState::VT_MULTISAMPLESTATE, multisampleState);
  }
  void add_depthStencilState(const mslb::DepthStencilState *depthStencilState) {
    fbb_.AddStruct(RenderState::VT_DEPTHSTENCILSTATE, depthStencilState);
  }
  void add_blendState(flatbuffers::Offset<mslb::BlendState> blendState) {
    fbb_.AddOffset(RenderState::VT_BLENDSTATE, blendState);
  }
  void add_patchControlPoints(uint32_t patchControlPoints) {
    fbb_.AddElement<uint32_t>(RenderState::VT_PATCHCONTROLPOINTS, patchControlPoints, 0);
  }
  void add_clipDistanceCount(uint32_t clipDistanceCount) {
    fbb_.AddElement<uint32_t>(RenderState::VT_CLIPDISTANCECOUNT, clipDistanceCount, 0);
  }
  void add_cullDistanceCount(uint32_t cullDistanceCount) {
    fbb_.AddElement<uint32_t>(RenderState::VT_CULLDISTANCECOUNT, cullDistanceCount, 0);
  }
  void add_fragmentGroup(uint32_t fragmentGroup) {
    fbb_.AddElement<uint32_t>(RenderState::VT_FRAGMENTGROUP, fragmentGroup, 4294967295);
  }
  explicit RenderStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RenderState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderState>(end);
    fbb_.Required(o, RenderState::VT_RASTERIZATIONSTATE);
    fbb_.Required(o, RenderState::VT_MULTISAMPLESTATE);
    fbb_.Required(o, RenderState::VT_DEPTHSTENCILSTATE);
    fbb_.Required(o, RenderState::VT_BLENDSTATE);
    return o;
  }
};

inline flatbuffers::Offset<RenderState> CreateRenderState(
    flatbuffers::FlatBufferBuilder &_fbb,
    const mslb::RasterizationState *rasterizationState = nullptr,
    const mslb::MultisampleState *multisampleState = nullptr,
    const mslb::DepthStencilState *depthStencilState = nullptr,
    flatbuffers::Offset<mslb::BlendState> blendState = 0,
    uint32_t patchControlPoints = 0,
    uint32_t clipDistanceCount = 0,
    uint32_t cullDistanceCount = 0,
    uint32_t fragmentGroup = 4294967295) {
  RenderStateBuilder builder_(_fbb);
  builder_.add_fragmentGroup(fragmentGroup);
  builder_.add_cullDistanceCount(cullDistanceCount);
  builder_.add_clipDistanceCount(clipDistanceCount);
  builder_.add_patchControlPoints(patchControlPoints);
  builder_.add_blendState(blendState);
  builder_.add_depthStencilState(depthStencilState);
  builder_.add_multisampleState(multisampleState);
  builder_.add_rasterizationState(rasterizationState);
  return builder_.Finish();
}

struct StructMember FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StructMemberBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OFFSET = 6,
    VT_SIZE = 8,
    VT_TYPE = 10,
    VT_STRUCTINDEX = 12,
    VT_ARRAYELEMENTS = 14,
    VT_ROWMAJOR = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  bool mutate_offset(uint32_t _offset = 0) {
    return SetField<uint32_t>(VT_OFFSET, _offset, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size = 0) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  mslb::Type type() const {
    return static_cast<mslb::Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool mutate_type(mslb::Type _type = static_cast<mslb::Type>(0)) {
    return SetField<uint8_t>(VT_TYPE, static_cast<uint8_t>(_type), 0);
  }
  uint32_t structIndex() const {
    return GetField<uint32_t>(VT_STRUCTINDEX, 0);
  }
  bool mutate_structIndex(uint32_t _structIndex = 0) {
    return SetField<uint32_t>(VT_STRUCTINDEX, _structIndex, 0);
  }
  const flatbuffers::Vector<const mslb::ArrayInfo *> *arrayElements() const {
    return GetPointer<const flatbuffers::Vector<const mslb::ArrayInfo *> *>(VT_ARRAYELEMENTS);
  }
  flatbuffers::Vector<const mslb::ArrayInfo *> *mutable_arrayElements() {
    return GetPointer<flatbuffers::Vector<const mslb::ArrayInfo *> *>(VT_ARRAYELEMENTS);
  }
  bool rowMajor() const {
    return GetField<uint8_t>(VT_ROWMAJOR, 0) != 0;
  }
  bool mutate_rowMajor(bool _rowMajor = 0) {
    return SetField<uint8_t>(VT_ROWMAJOR, static_cast<uint8_t>(_rowMajor), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_STRUCTINDEX, 4) &&
           VerifyOffset(verifier, VT_ARRAYELEMENTS) &&
           verifier.VerifyVector(arrayElements()) &&
           VerifyField<uint8_t>(verifier, VT_ROWMAJOR, 1) &&
           verifier.EndTable();
  }
};

struct StructMemberBuilder {
  typedef StructMember Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(StructMember::VT_NAME, name);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(StructMember::VT_OFFSET, offset, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(StructMember::VT_SIZE, size, 0);
  }
  void add_type(mslb::Type type) {
    fbb_.AddElement<uint8_t>(StructMember::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_structIndex(uint32_t structIndex) {
    fbb_.AddElement<uint32_t>(StructMember::VT_STRUCTINDEX, structIndex, 0);
  }
  void add_arrayElements(flatbuffers::Offset<flatbuffers::Vector<const mslb::ArrayInfo *>> arrayElements) {
    fbb_.AddOffset(StructMember::VT_ARRAYELEMENTS, arrayElements);
  }
  void add_rowMajor(bool rowMajor) {
    fbb_.AddElement<uint8_t>(StructMember::VT_ROWMAJOR, static_cast<uint8_t>(rowMajor), 0);
  }
  explicit StructMemberBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StructMember> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StructMember>(end);
    fbb_.Required(o, StructMember::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<StructMember> CreateStructMember(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t offset = 0,
    uint32_t size = 0,
    mslb::Type type = mslb::Type::Float,
    uint32_t structIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<const mslb::ArrayInfo *>> arrayElements = 0,
    bool rowMajor = false) {
  StructMemberBuilder builder_(_fbb);
  builder_.add_arrayElements(arrayElements);
  builder_.add_structIndex(structIndex);
  builder_.add_size(size);
  builder_.add_offset(offset);
  builder_.add_name(name);
  builder_.add_rowMajor(rowMajor);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<StructMember> CreateStructMemberDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t offset = 0,
    uint32_t size = 0,
    mslb::Type type = mslb::Type::Float,
    uint32_t structIndex = 0,
    const std::vector<mslb::ArrayInfo> *arrayElements = nullptr,
    bool rowMajor = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto arrayElements__ = arrayElements ? _fbb.CreateVectorOfStructs<mslb::ArrayInfo>(*arrayElements) : 0;
  return mslb::CreateStructMember(
      _fbb,
      name__,
      offset,
      size,
      type,
      structIndex,
      arrayElements__,
      rowMajor);
}

struct Struct FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StructBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIZE = 6,
    VT_MEMBERS = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size = 0) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mslb::StructMember>> *members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mslb::StructMember>> *>(VT_MEMBERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<mslb::StructMember>> *mutable_members() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mslb::StructMember>> *>(VT_MEMBERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyOffsetRequired(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(members()) &&
           verifier.VerifyVectorOfTables(members()) &&
           verifier.EndTable();
  }
};

struct StructBuilder {
  typedef Struct Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Struct::VT_NAME, name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Struct::VT_SIZE, size, 0);
  }
  void add_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::StructMember>>> members) {
    fbb_.AddOffset(Struct::VT_MEMBERS, members);
  }
  explicit StructBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Struct> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Struct>(end);
    fbb_.Required(o, Struct::VT_NAME);
    fbb_.Required(o, Struct::VT_MEMBERS);
    return o;
  }
};

inline flatbuffers::Offset<Struct> CreateStruct(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t size = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::StructMember>>> members = 0) {
  StructBuilder builder_(_fbb);
  builder_.add_members(members);
  builder_.add_size(size);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Struct> CreateStructDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t size = 0,
    const std::vector<flatbuffers::Offset<mslb::StructMember>> *members = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto members__ = members ? _fbb.CreateVector<flatbuffers::Offset<mslb::StructMember>>(*members) : 0;
  return mslb::CreateStruct(
      _fbb,
      name__,
      size,
      members__);
}

struct Uniform FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UniformBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_UNIFORMTYPE = 6,
    VT_TYPE = 8,
    VT_STRUCTINDEX = 10,
    VT_ARRAYELEMENTS = 12,
    VT_DESCRIPTORSET = 14,
    VT_BINDING = 16,
    VT_INPUTATTACHMENTINDEX = 18,
    VT_SAMPLERINDEX = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  mslb::UniformType uniformType() const {
    return static_cast<mslb::UniformType>(GetField<uint8_t>(VT_UNIFORMTYPE, 0));
  }
  bool mutate_uniformType(mslb::UniformType _uniformType = static_cast<mslb::UniformType>(0)) {
    return SetField<uint8_t>(VT_UNIFORMTYPE, static_cast<uint8_t>(_uniformType), 0);
  }
  mslb::Type type() const {
    return static_cast<mslb::Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool mutate_type(mslb::Type _type = static_cast<mslb::Type>(0)) {
    return SetField<uint8_t>(VT_TYPE, static_cast<uint8_t>(_type), 0);
  }
  uint32_t structIndex() const {
    return GetField<uint32_t>(VT_STRUCTINDEX, 0);
  }
  bool mutate_structIndex(uint32_t _structIndex = 0) {
    return SetField<uint32_t>(VT_STRUCTINDEX, _structIndex, 0);
  }
  const flatbuffers::Vector<const mslb::ArrayInfo *> *arrayElements() const {
    return GetPointer<const flatbuffers::Vector<const mslb::ArrayInfo *> *>(VT_ARRAYELEMENTS);
  }
  flatbuffers::Vector<const mslb::ArrayInfo *> *mutable_arrayElements() {
    return GetPointer<flatbuffers::Vector<const mslb::ArrayInfo *> *>(VT_ARRAYELEMENTS);
  }
  uint32_t descriptorSet() const {
    return GetField<uint32_t>(VT_DESCRIPTORSET, 0);
  }
  bool mutate_descriptorSet(uint32_t _descriptorSet = 0) {
    return SetField<uint32_t>(VT_DESCRIPTORSET, _descriptorSet, 0);
  }
  uint32_t binding() const {
    return GetField<uint32_t>(VT_BINDING, 0);
  }
  bool mutate_binding(uint32_t _binding = 0) {
    return SetField<uint32_t>(VT_BINDING, _binding, 0);
  }
  uint32_t inputAttachmentIndex() const {
    return GetField<uint32_t>(VT_INPUTATTACHMENTINDEX, 0);
  }
  bool mutate_inputAttachmentIndex(uint32_t _inputAttachmentIndex = 0) {
    return SetField<uint32_t>(VT_INPUTATTACHMENTINDEX, _inputAttachmentIndex, 0);
  }
  uint32_t samplerIndex() const {
    return GetField<uint32_t>(VT_SAMPLERINDEX, 0);
  }
  bool mutate_samplerIndex(uint32_t _samplerIndex = 0) {
    return SetField<uint32_t>(VT_SAMPLERINDEX, _samplerIndex, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_UNIFORMTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_STRUCTINDEX, 4) &&
           VerifyOffset(verifier, VT_ARRAYELEMENTS) &&
           verifier.VerifyVector(arrayElements()) &&
           VerifyField<uint32_t>(verifier, VT_DESCRIPTORSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_BINDING, 4) &&
           VerifyField<uint32_t>(verifier, VT_INPUTATTACHMENTINDEX, 4) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLERINDEX, 4) &&
           verifier.EndTable();
  }
};

struct UniformBuilder {
  typedef Uniform Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Uniform::VT_NAME, name);
  }
  void add_uniformType(mslb::UniformType uniformType) {
    fbb_.AddElement<uint8_t>(Uniform::VT_UNIFORMTYPE, static_cast<uint8_t>(uniformType), 0);
  }
  void add_type(mslb::Type type) {
    fbb_.AddElement<uint8_t>(Uniform::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_structIndex(uint32_t structIndex) {
    fbb_.AddElement<uint32_t>(Uniform::VT_STRUCTINDEX, structIndex, 0);
  }
  void add_arrayElements(flatbuffers::Offset<flatbuffers::Vector<const mslb::ArrayInfo *>> arrayElements) {
    fbb_.AddOffset(Uniform::VT_ARRAYELEMENTS, arrayElements);
  }
  void add_descriptorSet(uint32_t descriptorSet) {
    fbb_.AddElement<uint32_t>(Uniform::VT_DESCRIPTORSET, descriptorSet, 0);
  }
  void add_binding(uint32_t binding) {
    fbb_.AddElement<uint32_t>(Uniform::VT_BINDING, binding, 0);
  }
  void add_inputAttachmentIndex(uint32_t inputAttachmentIndex) {
    fbb_.AddElement<uint32_t>(Uniform::VT_INPUTATTACHMENTINDEX, inputAttachmentIndex, 0);
  }
  void add_samplerIndex(uint32_t samplerIndex) {
    fbb_.AddElement<uint32_t>(Uniform::VT_SAMPLERINDEX, samplerIndex, 0);
  }
  explicit UniformBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Uniform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uniform>(end);
    fbb_.Required(o, Uniform::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Uniform> CreateUniform(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    mslb::UniformType uniformType = mslb::UniformType::PushConstant,
    mslb::Type type = mslb::Type::Float,
    uint32_t structIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<const mslb::ArrayInfo *>> arrayElements = 0,
    uint32_t descriptorSet = 0,
    uint32_t binding = 0,
    uint32_t inputAttachmentIndex = 0,
    uint32_t samplerIndex = 0) {
  UniformBuilder builder_(_fbb);
  builder_.add_samplerIndex(samplerIndex);
  builder_.add_inputAttachmentIndex(inputAttachmentIndex);
  builder_.add_binding(binding);
  builder_.add_descriptorSet(descriptorSet);
  builder_.add_arrayElements(arrayElements);
  builder_.add_structIndex(structIndex);
  builder_.add_name(name);
  builder_.add_type(type);
  builder_.add_uniformType(uniformType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uniform> CreateUniformDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    mslb::UniformType uniformType = mslb::UniformType::PushConstant,
    mslb::Type type = mslb::Type::Float,
    uint32_t structIndex = 0,
    const std::vector<mslb::ArrayInfo> *arrayElements = nullptr,
    uint32_t descriptorSet = 0,
    uint32_t binding = 0,
    uint32_t inputAttachmentIndex = 0,
    uint32_t samplerIndex = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto arrayElements__ = arrayElements ? _fbb.CreateVectorOfStructs<mslb::ArrayInfo>(*arrayElements) : 0;
  return mslb::CreateUniform(
      _fbb,
      name__,
      uniformType,
      type,
      structIndex,
      arrayElements__,
      descriptorSet,
      binding,
      inputAttachmentIndex,
      samplerIndex);
}

struct Attribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_ARRAYELEMENTS = 8,
    VT_LOCATION = 10,
    VT_COMPONENT = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  mslb::Type type() const {
    return static_cast<mslb::Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool mutate_type(mslb::Type _type = static_cast<mslb::Type>(0)) {
    return SetField<uint8_t>(VT_TYPE, static_cast<uint8_t>(_type), 0);
  }
  const flatbuffers::Vector<uint32_t> *arrayElements() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ARRAYELEMENTS);
  }
  flatbuffers::Vector<uint32_t> *mutable_arrayElements() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_ARRAYELEMENTS);
  }
  uint32_t location() const {
    return GetField<uint32_t>(VT_LOCATION, 0);
  }
  bool mutate_location(uint32_t _location = 0) {
    return SetField<uint32_t>(VT_LOCATION, _location, 0);
  }
  uint32_t component() const {
    return GetField<uint32_t>(VT_COMPONENT, 0);
  }
  bool mutate_component(uint32_t _component = 0) {
    return SetField<uint32_t>(VT_COMPONENT, _component, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_ARRAYELEMENTS) &&
           verifier.VerifyVector(arrayElements()) &&
           VerifyField<uint32_t>(verifier, VT_LOCATION, 4) &&
           VerifyField<uint32_t>(verifier, VT_COMPONENT, 4) &&
           verifier.EndTable();
  }
};

struct AttributeBuilder {
  typedef Attribute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Attribute::VT_NAME, name);
  }
  void add_type(mslb::Type type) {
    fbb_.AddElement<uint8_t>(Attribute::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_arrayElements(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> arrayElements) {
    fbb_.AddOffset(Attribute::VT_ARRAYELEMENTS, arrayElements);
  }
  void add_location(uint32_t location) {
    fbb_.AddElement<uint32_t>(Attribute::VT_LOCATION, location, 0);
  }
  void add_component(uint32_t component) {
    fbb_.AddElement<uint32_t>(Attribute::VT_COMPONENT, component, 0);
  }
  explicit AttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attribute>(end);
    fbb_.Required(o, Attribute::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<Attribute> CreateAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    mslb::Type type = mslb::Type::Float,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> arrayElements = 0,
    uint32_t location = 0,
    uint32_t component = 0) {
  AttributeBuilder builder_(_fbb);
  builder_.add_component(component);
  builder_.add_location(location);
  builder_.add_arrayElements(arrayElements);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attribute> CreateAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    mslb::Type type = mslb::Type::Float,
    const std::vector<uint32_t> *arrayElements = nullptr,
    uint32_t location = 0,
    uint32_t component = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto arrayElements__ = arrayElements ? _fbb.CreateVector<uint32_t>(*arrayElements) : 0;
  return mslb::CreateAttribute(
      _fbb,
      name__,
      type,
      arrayElements__,
      location,
      component);
}

struct FragmentOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FragmentOutputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_LOCATION = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  uint32_t location() const {
    return GetField<uint32_t>(VT_LOCATION, 0);
  }
  bool mutate_location(uint32_t _location = 0) {
    return SetField<uint32_t>(VT_LOCATION, _location, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_LOCATION, 4) &&
           verifier.EndTable();
  }
};

struct FragmentOutputBuilder {
  typedef FragmentOutput Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FragmentOutput::VT_NAME, name);
  }
  void add_location(uint32_t location) {
    fbb_.AddElement<uint32_t>(FragmentOutput::VT_LOCATION, location, 0);
  }
  explicit FragmentOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FragmentOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FragmentOutput>(end);
    fbb_.Required(o, FragmentOutput::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<FragmentOutput> CreateFragmentOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t location = 0) {
  FragmentOutputBuilder builder_(_fbb);
  builder_.add_location(location);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FragmentOutput> CreateFragmentOutputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t location = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return mslb::CreateFragmentOutput(
      _fbb,
      name__,
      location);
}

struct Shader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHADER = 4,
    VT_UNIFORMIDS = 6
  };
  uint32_t shader() const {
    return GetField<uint32_t>(VT_SHADER, 0);
  }
  bool mutate_shader(uint32_t _shader = 0) {
    return SetField<uint32_t>(VT_SHADER, _shader, 0);
  }
  const flatbuffers::Vector<uint32_t> *uniformIds() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_UNIFORMIDS);
  }
  flatbuffers::Vector<uint32_t> *mutable_uniformIds() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_UNIFORMIDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SHADER, 4) &&
           VerifyOffset(verifier, VT_UNIFORMIDS) &&
           verifier.VerifyVector(uniformIds()) &&
           verifier.EndTable();
  }
};

struct ShaderBuilder {
  typedef Shader Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shader(uint32_t shader) {
    fbb_.AddElement<uint32_t>(Shader::VT_SHADER, shader, 0);
  }
  void add_uniformIds(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> uniformIds) {
    fbb_.AddOffset(Shader::VT_UNIFORMIDS, uniformIds);
  }
  explicit ShaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Shader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shader>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shader> CreateShader(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t shader = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> uniformIds = 0) {
  ShaderBuilder builder_(_fbb);
  builder_.add_uniformIds(uniformIds);
  builder_.add_shader(shader);
  return builder_.Finish();
}

inline flatbuffers::Offset<Shader> CreateShaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t shader = 0,
    const std::vector<uint32_t> *uniformIds = nullptr) {
  auto uniformIds__ = uniformIds ? _fbb.CreateVector<uint32_t>(*uniformIds) : 0;
  return mslb::CreateShader(
      _fbb,
      shader,
      uniformIds__);
}

struct Pipeline FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PipelineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_STRUCTS = 6,
    VT_SAMPLERSTATES = 8,
    VT_UNIFORMS = 10,
    VT_ATTRIBUTES = 12,
    VT_FRAGMENTOUTPUTS = 14,
    VT_PUSHCONSTANTSTRUCT = 16,
    VT_RENDERSTATE = 18,
    VT_SHADERS = 20,
    VT_COMPUTLOCALSIZE = 22
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  flatbuffers::String *mutable_name() {
    return GetPointer<flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mslb::Struct>> *structs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mslb::Struct>> *>(VT_STRUCTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<mslb::Struct>> *mutable_structs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mslb::Struct>> *>(VT_STRUCTS);
  }
  const flatbuffers::Vector<const mslb::SamplerState *> *samplerStates() const {
    return GetPointer<const flatbuffers::Vector<const mslb::SamplerState *> *>(VT_SAMPLERSTATES);
  }
  flatbuffers::Vector<const mslb::SamplerState *> *mutable_samplerStates() {
    return GetPointer<flatbuffers::Vector<const mslb::SamplerState *> *>(VT_SAMPLERSTATES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mslb::Uniform>> *uniforms() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mslb::Uniform>> *>(VT_UNIFORMS);
  }
  flatbuffers::Vector<flatbuffers::Offset<mslb::Uniform>> *mutable_uniforms() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mslb::Uniform>> *>(VT_UNIFORMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mslb::Attribute>> *attributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mslb::Attribute>> *>(VT_ATTRIBUTES);
  }
  flatbuffers::Vector<flatbuffers::Offset<mslb::Attribute>> *mutable_attributes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mslb::Attribute>> *>(VT_ATTRIBUTES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mslb::FragmentOutput>> *fragmentOutputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mslb::FragmentOutput>> *>(VT_FRAGMENTOUTPUTS);
  }
  flatbuffers::Vector<flatbuffers::Offset<mslb::FragmentOutput>> *mutable_fragmentOutputs() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mslb::FragmentOutput>> *>(VT_FRAGMENTOUTPUTS);
  }
  uint32_t pushConstantStruct() const {
    return GetField<uint32_t>(VT_PUSHCONSTANTSTRUCT, 0);
  }
  bool mutate_pushConstantStruct(uint32_t _pushConstantStruct = 0) {
    return SetField<uint32_t>(VT_PUSHCONSTANTSTRUCT, _pushConstantStruct, 0);
  }
  const mslb::RenderState *renderState() const {
    return GetPointer<const mslb::RenderState *>(VT_RENDERSTATE);
  }
  mslb::RenderState *mutable_renderState() {
    return GetPointer<mslb::RenderState *>(VT_RENDERSTATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mslb::Shader>> *shaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mslb::Shader>> *>(VT_SHADERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<mslb::Shader>> *mutable_shaders() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mslb::Shader>> *>(VT_SHADERS);
  }
  const mslb::ComputeLocalSize *computLocalSize() const {
    return GetStruct<const mslb::ComputeLocalSize *>(VT_COMPUTLOCALSIZE);
  }
  mslb::ComputeLocalSize *mutable_computLocalSize() {
    return GetStruct<mslb::ComputeLocalSize *>(VT_COMPUTLOCALSIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_STRUCTS) &&
           verifier.VerifyVector(structs()) &&
           verifier.VerifyVectorOfTables(structs()) &&
           VerifyOffsetRequired(verifier, VT_SAMPLERSTATES) &&
           verifier.VerifyVector(samplerStates()) &&
           VerifyOffsetRequired(verifier, VT_UNIFORMS) &&
           verifier.VerifyVector(uniforms()) &&
           verifier.VerifyVectorOfTables(uniforms()) &&
           VerifyOffsetRequired(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyOffsetRequired(verifier, VT_FRAGMENTOUTPUTS) &&
           verifier.VerifyVector(fragmentOutputs()) &&
           verifier.VerifyVectorOfTables(fragmentOutputs()) &&
           VerifyField<uint32_t>(verifier, VT_PUSHCONSTANTSTRUCT, 4) &&
           VerifyOffsetRequired(verifier, VT_RENDERSTATE) &&
           verifier.VerifyTable(renderState()) &&
           VerifyOffsetRequired(verifier, VT_SHADERS) &&
           verifier.VerifyVector(shaders()) &&
           verifier.VerifyVectorOfTables(shaders()) &&
           VerifyField<mslb::ComputeLocalSize>(verifier, VT_COMPUTLOCALSIZE, 4) &&
           verifier.EndTable();
  }
};

struct PipelineBuilder {
  typedef Pipeline Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Pipeline::VT_NAME, name);
  }
  void add_structs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::Struct>>> structs) {
    fbb_.AddOffset(Pipeline::VT_STRUCTS, structs);
  }
  void add_samplerStates(flatbuffers::Offset<flatbuffers::Vector<const mslb::SamplerState *>> samplerStates) {
    fbb_.AddOffset(Pipeline::VT_SAMPLERSTATES, samplerStates);
  }
  void add_uniforms(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::Uniform>>> uniforms) {
    fbb_.AddOffset(Pipeline::VT_UNIFORMS, uniforms);
  }
  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::Attribute>>> attributes) {
    fbb_.AddOffset(Pipeline::VT_ATTRIBUTES, attributes);
  }
  void add_fragmentOutputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::FragmentOutput>>> fragmentOutputs) {
    fbb_.AddOffset(Pipeline::VT_FRAGMENTOUTPUTS, fragmentOutputs);
  }
  void add_pushConstantStruct(uint32_t pushConstantStruct) {
    fbb_.AddElement<uint32_t>(Pipeline::VT_PUSHCONSTANTSTRUCT, pushConstantStruct, 0);
  }
  void add_renderState(flatbuffers::Offset<mslb::RenderState> renderState) {
    fbb_.AddOffset(Pipeline::VT_RENDERSTATE, renderState);
  }
  void add_shaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::Shader>>> shaders) {
    fbb_.AddOffset(Pipeline::VT_SHADERS, shaders);
  }
  void add_computLocalSize(const mslb::ComputeLocalSize *computLocalSize) {
    fbb_.AddStruct(Pipeline::VT_COMPUTLOCALSIZE, computLocalSize);
  }
  explicit PipelineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pipeline> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pipeline>(end);
    fbb_.Required(o, Pipeline::VT_NAME);
    fbb_.Required(o, Pipeline::VT_STRUCTS);
    fbb_.Required(o, Pipeline::VT_SAMPLERSTATES);
    fbb_.Required(o, Pipeline::VT_UNIFORMS);
    fbb_.Required(o, Pipeline::VT_ATTRIBUTES);
    fbb_.Required(o, Pipeline::VT_FRAGMENTOUTPUTS);
    fbb_.Required(o, Pipeline::VT_RENDERSTATE);
    fbb_.Required(o, Pipeline::VT_SHADERS);
    return o;
  }
};

inline flatbuffers::Offset<Pipeline> CreatePipeline(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::Struct>>> structs = 0,
    flatbuffers::Offset<flatbuffers::Vector<const mslb::SamplerState *>> samplerStates = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::Uniform>>> uniforms = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::Attribute>>> attributes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::FragmentOutput>>> fragmentOutputs = 0,
    uint32_t pushConstantStruct = 0,
    flatbuffers::Offset<mslb::RenderState> renderState = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::Shader>>> shaders = 0,
    const mslb::ComputeLocalSize *computLocalSize = nullptr) {
  PipelineBuilder builder_(_fbb);
  builder_.add_computLocalSize(computLocalSize);
  builder_.add_shaders(shaders);
  builder_.add_renderState(renderState);
  builder_.add_pushConstantStruct(pushConstantStruct);
  builder_.add_fragmentOutputs(fragmentOutputs);
  builder_.add_attributes(attributes);
  builder_.add_uniforms(uniforms);
  builder_.add_samplerStates(samplerStates);
  builder_.add_structs(structs);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pipeline> CreatePipelineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<mslb::Struct>> *structs = nullptr,
    const std::vector<mslb::SamplerState> *samplerStates = nullptr,
    const std::vector<flatbuffers::Offset<mslb::Uniform>> *uniforms = nullptr,
    const std::vector<flatbuffers::Offset<mslb::Attribute>> *attributes = nullptr,
    const std::vector<flatbuffers::Offset<mslb::FragmentOutput>> *fragmentOutputs = nullptr,
    uint32_t pushConstantStruct = 0,
    flatbuffers::Offset<mslb::RenderState> renderState = 0,
    const std::vector<flatbuffers::Offset<mslb::Shader>> *shaders = nullptr,
    const mslb::ComputeLocalSize *computLocalSize = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto structs__ = structs ? _fbb.CreateVector<flatbuffers::Offset<mslb::Struct>>(*structs) : 0;
  auto samplerStates__ = samplerStates ? _fbb.CreateVectorOfStructs<mslb::SamplerState>(*samplerStates) : 0;
  auto uniforms__ = uniforms ? _fbb.CreateVector<flatbuffers::Offset<mslb::Uniform>>(*uniforms) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<flatbuffers::Offset<mslb::Attribute>>(*attributes) : 0;
  auto fragmentOutputs__ = fragmentOutputs ? _fbb.CreateVector<flatbuffers::Offset<mslb::FragmentOutput>>(*fragmentOutputs) : 0;
  auto shaders__ = shaders ? _fbb.CreateVector<flatbuffers::Offset<mslb::Shader>>(*shaders) : 0;
  return mslb::CreatePipeline(
      _fbb,
      name__,
      structs__,
      samplerStates__,
      uniforms__,
      attributes__,
      fragmentOutputs__,
      pushConstantStruct,
      renderState,
      shaders__,
      computLocalSize);
}

struct ShaderData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShaderDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4,
    VT_USESPUSHCONSTANTS = 6
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool usesPushConstants() const {
    return GetField<uint8_t>(VT_USESPUSHCONSTANTS, 1) != 0;
  }
  bool mutate_usesPushConstants(bool _usesPushConstants = 1) {
    return SetField<uint8_t>(VT_USESPUSHCONSTANTS, static_cast<uint8_t>(_usesPushConstants), 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyField<uint8_t>(verifier, VT_USESPUSHCONSTANTS, 1) &&
           verifier.EndTable();
  }
};

struct ShaderDataBuilder {
  typedef ShaderData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ShaderData::VT_DATA, data);
  }
  void add_usesPushConstants(bool usesPushConstants) {
    fbb_.AddElement<uint8_t>(ShaderData::VT_USESPUSHCONSTANTS, static_cast<uint8_t>(usesPushConstants), 1);
  }
  explicit ShaderDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ShaderData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShaderData>(end);
    fbb_.Required(o, ShaderData::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<ShaderData> CreateShaderData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    bool usesPushConstants = true) {
  ShaderDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_usesPushConstants(usesPushConstants);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShaderData> CreateShaderDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr,
    bool usesPushConstants = true) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return mslb::CreateShaderData(
      _fbb,
      data__,
      usesPushConstants);
}

struct Module FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModuleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_TARGETID = 6,
    VT_TARGETVERSION = 8,
    VT_ADJUSTABLEBINDINGS = 10,
    VT_PIPELINES = 12,
    VT_SHADERS = 14,
    VT_SHAREDDATA = 16
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version = 0) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  uint32_t targetId() const {
    return GetField<uint32_t>(VT_TARGETID, 0);
  }
  bool mutate_targetId(uint32_t _targetId = 0) {
    return SetField<uint32_t>(VT_TARGETID, _targetId, 0);
  }
  uint32_t targetVersion() const {
    return GetField<uint32_t>(VT_TARGETVERSION, 0);
  }
  bool mutate_targetVersion(uint32_t _targetVersion = 0) {
    return SetField<uint32_t>(VT_TARGETVERSION, _targetVersion, 0);
  }
  bool adjustableBindings() const {
    return GetField<uint8_t>(VT_ADJUSTABLEBINDINGS, 0) != 0;
  }
  bool mutate_adjustableBindings(bool _adjustableBindings = 0) {
    return SetField<uint8_t>(VT_ADJUSTABLEBINDINGS, static_cast<uint8_t>(_adjustableBindings), 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mslb::Pipeline>> *pipelines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mslb::Pipeline>> *>(VT_PIPELINES);
  }
  flatbuffers::Vector<flatbuffers::Offset<mslb::Pipeline>> *mutable_pipelines() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mslb::Pipeline>> *>(VT_PIPELINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mslb::ShaderData>> *shaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mslb::ShaderData>> *>(VT_SHADERS);
  }
  flatbuffers::Vector<flatbuffers::Offset<mslb::ShaderData>> *mutable_shaders() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<mslb::ShaderData>> *>(VT_SHADERS);
  }
  const flatbuffers::Vector<uint8_t> *sharedData() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SHAREDDATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_sharedData() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_SHAREDDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           VerifyField<uint32_t>(verifier, VT_TARGETID, 4) &&
           VerifyField<uint32_t>(verifier, VT_TARGETVERSION, 4) &&
           VerifyField<uint8_t>(verifier, VT_ADJUSTABLEBINDINGS, 1) &&
           VerifyOffsetRequired(verifier, VT_PIPELINES) &&
           verifier.VerifyVector(pipelines()) &&
           verifier.VerifyVectorOfTables(pipelines()) &&
           VerifyOffsetRequired(verifier, VT_SHADERS) &&
           verifier.VerifyVector(shaders()) &&
           verifier.VerifyVectorOfTables(shaders()) &&
           VerifyOffsetRequired(verifier, VT_SHAREDDATA) &&
           verifier.VerifyVector(sharedData()) &&
           verifier.EndTable();
  }
};

struct ModuleBuilder {
  typedef Module Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Module::VT_VERSION, version, 0);
  }
  void add_targetId(uint32_t targetId) {
    fbb_.AddElement<uint32_t>(Module::VT_TARGETID, targetId, 0);
  }
  void add_targetVersion(uint32_t targetVersion) {
    fbb_.AddElement<uint32_t>(Module::VT_TARGETVERSION, targetVersion, 0);
  }
  void add_adjustableBindings(bool adjustableBindings) {
    fbb_.AddElement<uint8_t>(Module::VT_ADJUSTABLEBINDINGS, static_cast<uint8_t>(adjustableBindings), 0);
  }
  void add_pipelines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::Pipeline>>> pipelines) {
    fbb_.AddOffset(Module::VT_PIPELINES, pipelines);
  }
  void add_shaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::ShaderData>>> shaders) {
    fbb_.AddOffset(Module::VT_SHADERS, shaders);
  }
  void add_sharedData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sharedData) {
    fbb_.AddOffset(Module::VT_SHAREDDATA, sharedData);
  }
  explicit ModuleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Module> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Module>(end);
    fbb_.Required(o, Module::VT_PIPELINES);
    fbb_.Required(o, Module::VT_SHADERS);
    fbb_.Required(o, Module::VT_SHAREDDATA);
    return o;
  }
};

inline flatbuffers::Offset<Module> CreateModule(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    uint32_t targetId = 0,
    uint32_t targetVersion = 0,
    bool adjustableBindings = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::Pipeline>>> pipelines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mslb::ShaderData>>> shaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> sharedData = 0) {
  ModuleBuilder builder_(_fbb);
  builder_.add_sharedData(sharedData);
  builder_.add_shaders(shaders);
  builder_.add_pipelines(pipelines);
  builder_.add_targetVersion(targetVersion);
  builder_.add_targetId(targetId);
  builder_.add_version(version);
  builder_.add_adjustableBindings(adjustableBindings);
  return builder_.Finish();
}

inline flatbuffers::Offset<Module> CreateModuleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    uint32_t targetId = 0,
    uint32_t targetVersion = 0,
    bool adjustableBindings = false,
    const std::vector<flatbuffers::Offset<mslb::Pipeline>> *pipelines = nullptr,
    const std::vector<flatbuffers::Offset<mslb::ShaderData>> *shaders = nullptr,
    const std::vector<uint8_t> *sharedData = nullptr) {
  auto pipelines__ = pipelines ? _fbb.CreateVector<flatbuffers::Offset<mslb::Pipeline>>(*pipelines) : 0;
  auto shaders__ = shaders ? _fbb.CreateVector<flatbuffers::Offset<mslb::ShaderData>>(*shaders) : 0;
  auto sharedData__ = sharedData ? _fbb.CreateVector<uint8_t>(*sharedData) : 0;
  return mslb::CreateModule(
      _fbb,
      version,
      targetId,
      targetVersion,
      adjustableBindings,
      pipelines__,
      shaders__,
      sharedData__);
}

inline const mslb::Module *GetModule(const void *buf) {
  return flatbuffers::GetRoot<mslb::Module>(buf);
}

inline const mslb::Module *GetSizePrefixedModule(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<mslb::Module>(buf);
}

inline Module *GetMutableModule(void *buf) {
  return flatbuffers::GetMutableRoot<Module>(buf);
}

inline mslb::Module *GetMutableSizePrefixedModule(void *buf) {
  return flatbuffers::GetMutableSizePrefixedRoot<mslb::Module>(buf);
}

inline bool VerifyModuleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mslb::Module>(nullptr);
}

inline bool VerifySizePrefixedModuleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<mslb::Module>(nullptr);
}

inline void FinishModuleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mslb::Module> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedModuleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mslb::Module> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace mslb

#endif  // FLATBUFFERS_GENERATED_MSLB_MSLB_H_
